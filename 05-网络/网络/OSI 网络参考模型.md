
![](https://i0.hdslb.com/bfs/note/997758893fd1a7d53823c6f980d656f1f0e74424.jpg@640w_!web-note.webp)

仅作为参考，也就是说OSI网络实际中并不使用

我们只是把OSI网络模型作为参考，在网络出现问题的时候，可以从一个宏观的整体去分析和解决问题

而且搭建网络的时候也并不一定需要划分为7层

![](https://i0.hdslb.com/bfs/note/9e30ce14a3c649e1d9169baefa20c2575dbf3a06.jpg@640w_!web-note.webp)

但是当今互联网广泛使用的是TCP/IP网络模型

他原本是四层，实际上划分为五层更符合实


OSI模型的目的：解决主机之间的网络通讯

例子：

华为电脑用浏览器访问苹果电脑搭建的网站

两个应用具体需要如何进行交互就是应用层的事情了

应用层并不是说你需要使用什么应用程序

而是应用如何沟通

常用的应用层协议HTTP协议

![](https://i0.hdslb.com/bfs/note/84095f166ed6c247b6fc63ccd8dff39fd1316469.jpg@640w_!web-note.webp)

使得应用之间可以实现沟通

应用层就是最接近用户的那一层

但是应用层只不过是逻辑上把两个两个应用连通

实际物理上的连通是需要物理层的

我们要发送出去的数据在计算机里只不过是无数的0和1

0或者1就叫做比特

## 物理层 
物理层就要把这些比特用不同的媒介传输出去

![](https://i0.hdslb.com/bfs/note/c447e6a3db80e6ae52740a8a629df6af6ce96e2b.jpg@640w_!web-note.webp)

可以用电，用光或者其他形式的电磁波来表示和传输信号

数据从网络接口出去以后会经过不同的网络拓扑

![](https://i0.hdslb.com/bfs/note/c67448acebcdf101387ab42ef53c24a4f62698cb.jpg@640w_!web-note.webp)

并不是一条线走到底

因此需要中继器和集线器这样的设备

![](https://i0.hdslb.com/bfs/note/2948d3feaa72d3fbcef02142c6dd0e1e9cc7c3aa.jpg@640w_!web-note.webp)

但还是不够

信号要去到哪台设备是需要定向的

因此需要高级一点的网络模型
## 数据链路层

在数据链路层这里

比特会被封装成帧

![](https://i0.hdslb.com/bfs/note/4156daa3c111d8074f62a905631a37072a4cd949.jpg@640w_!web-note.webp)

帧就是这一层表示数据的特殊名字而已

在封装的时候会加上MAC地址

也就是传说中的物理地址

网卡出厂的时候就有着全球唯一的MAC地址

![](https://i0.hdslb.com/bfs/note/a6817f9574b5163bc7dc6bc2e62ab98009fb511a.jpg@640w_!web-note.webp)

为了可以通过MAC地址对不同设备进行数据的传输

就出现了交换机

![](https://i0.hdslb.com/bfs/note/2e9533b05e7005221660d117ad977d8e73a694f5.jpg@640w_!web-note.webp)

这里说的是二层交换机

![](https://i0.hdslb.com/bfs/note/3a4403747ef31418ae02b81a4b7d59f52059305f.jpg@640w_!web-note.webp)

  

比方说这里有一台交换机

连接多台主机

发送端发送数据的时候

交换机就知道了发送端的MAC地址

如果此时交换机也知道接收端的MAC地址

就可以把数据直接发送过去了

物理地址就是这样一跳一跳地进行传递

![](https://i0.hdslb.com/bfs/note/904844122f5de61b3eb5443e154ff1624705a197.jpg@640w_!web-note.webp)

另外因为物理层在传输0和1的时候

![](https://i0.hdslb.com/bfs/note/69507817c90c491ff969dd68d27d012b2df4f3dc.jpg@640w_!web-note.webp)

可能会0变成1，或者1变成0

会进行差错检测

以及一定的差错纠正

另外设备之间的传输能力以及接受能力也是个问题

很可能这边“喷水”式传输，另一边“夹缝式”接受

因此需要流控制来避免这种不对称

我们知道互联网是一张大网

如果用MAC物理地址来作为唯一的寻址方法是不科学的
## 网络层

![](https://i0.hdslb.com/bfs/note/164debd50b618092730df0629cadba453d40b387.jpg@640w_!web-note.webp)

比如我和你买了同一个厂的网卡

我和你你的网卡差别只有一个字母

但是我和你距离十万八千里

物理地址此时就很难做出快速定位

相当于我有你的名字

但不知道你住哪里，找不到你

因此需要IP地址来进行寻址和路由选择

![](https://i0.hdslb.com/bfs/note/7295b22c43e4c5e9ce8068fcfe501f985eb1d823.jpg@640w_!web-note.webp)

IP这样的逻辑地址就是实现端到端的基础了

而不是物理地址那样的跳到跳传输

说到路由选择

也就是说路由器也是网络层的核心

包就是网络层里数据的名字

在封装为二层的帧之前就是包

路由器根据包里IP地址进行路由转发

![](https://i0.hdslb.com/bfs/note/d0e22e3cc534b3b1dd3241f1058fdf91467bf964.jpg@640w_!web-note.webp)

地址管理和路由选择就是这一层的核心

虽然有MAC和IP地址可以抵达对方主机
## 传输层

虽然有MAC和IP地址可以抵达对方主机

但是对方主机可能运行着无数多个软件进程

假设我用谷歌和火狐浏览器同时登录网站

如何让数据去到指定的软件服务上

就需要用到端口号作为地址来定位了

比如客户端这里生成不同的端口号

![](https://i0.hdslb.com/bfs/note/27b432945a0f3b71c207c49290cea87be9507ab4.jpg@640w_!web-note.webp)

即时同时访问HTTP端口80也是没问题的

根据不同的源端口号来作出响应就可以了

所以传输层（运输层）在网络层的端到端基础上

实现了服务进程到服务进程的传输

段就是传输层里数据的名字

![](https://i0.hdslb.com/bfs/note/53056a49c96b50c7fe1cfd29dd42d988475ed314.jpg@640w_!web-note.webp)

在封装为三层包之前就是段

等会名字会总结，不用害怕

传输层管理两个节点之间数据的传输

负责可靠传输和不可靠传输

![](https://i0.hdslb.com/bfs/note/c0401bd3e4bb0cf048a626d83852eb4e30045b03.jpg@640w_!web-note.webp)

既TCP UDP

另外还有一个新的叫QUIC

其中TCP允许应用把字节流变成多份段

![](https://i0.hdslb.com/bfs/note/c72c162a979735fc59e149be2701d78569404d0e.jpg@640w_!web-note.webp)

而不是整个字节数据完整地发送出去

![](https://i0.hdslb.com/bfs/note/720ffbb7873a38d1d5e809d304224d72b209d538.jpg@640w_!web-note.webp)

传输层还有流量控制来确保传输速度

再加上错误控制来进行数据完整的接收
## 会话层
**接下来会话层也比较好理解**


比方说你现在登录了某个网站

网站服务可以保持你的登录状态

不用每次都输入账号和密码

当然网站服务会管理和控制登录状态

另外会话层还负责同步服务

比方说你上次看到电影高潮的时刻突然停电了

再次登录账号的时候就可以自动同步岛上次看到的时间段

不同计算机内部的各自表达方式可能不太相同

﻿

06:59

﻿

表示层就来负责这样的转换

也就是编码和解码

数据往往还需要进行加密

比方说HTTPS( SSL/ TLS)就会对我们的数据进行加密和解密

另外我们可能还需要给文件瘦身

压缩也是这一层负责的

应用层，表示层和会话层的数据统称为应用数据或者应用负载也可以叫上层数据

同时也是教科书上说的报文

数据在各层的名字分别是

![](https://i0.hdslb.com/bfs/note/b20dac7e59dd966ac3fe914cf0cd6eebf8e4e984.jpg@640w_!web-note.webp)

报文，段，包，帧和比特

就地址来说

![](https://i0.hdslb.com/bfs/note/f96136be794c3be8c896a324651bae141f6f44ca.jpg@640w_!web-note.webp)

有端口号，IP逻辑地址和MAC物理地址

就传输功能来讲

![](https://i0.hdslb.com/bfs/note/1d4a869dd6deee7c309a8461e7579c9895011ede.jpg@640w_!web-note.webp)

有服务进程到服务进程，端到端，跳到跳

了解了各层的作用

现在就可以把全部关联起来

客户端要发送数据，也就是报文

报文来到传输层加上端口号，封装成段

段来到了网络层，加上IP地址，封住成包

注意这里的包是含有目标IP地址的

毕竟你要知道数据要发送到什么地方

![](https://i0.hdslb.com/bfs/note/ebf9f9f862a01f6d34f83d1f54226ed84d1f95a4.jpg@640w_!web-note.webp)

但因为目标IP地址不是同一个网络下的

要发送到其他的网络就需要经过默认网关

现在就出现了一个问题

客户端主机最初并不知道默认网关的MAC地址

没有办法封装成帧

这个时候就可以用ARP协议进行广播

找到网关IP对应的MAC地址把包封装成帧

![](https://i0.hdslb.com/bfs/note/e30d78b1a13a8eeedfc6316edd2012de376cd8d6.jpg@640w_!web-note.webp)

源MAC地址填自己的

目标MAC地址填广播地址

假设当前网络有个二层交换机

这个交换机只需要记录下不同的接口对应的MAC地址就好了

交换机收到广播后就帮忙发送出去“人手一份”

所以默认网关收到消息后查看了帧

发现了发送端的MAC地址

再解封发现包里面的IP地址

就会把客户端MAC地址和IP地址关联为一台主机

同时默认网关会把自己的IP地址放入包里

再结合自己的MAC地址封装成帧

默认网关就这样做出响应，这样原路返回

发送端就知道默认网关的MAC地址了

现在就可以封装成帧，并且发送数据

![](https://i0.hdslb.com/bfs/note/ed77c4a2bc2ba53a01335363736dbfbc620f16e5.jpg@640w_!web-note.webp)

比特流到了默认网关的时候

解封为帧发现是送给自己的

那解封为包查看到目标IP地址是在另一网络中的

就会进行路由转发，最终到达了目的网络

如果目标的网关知道目标IP地址和MAC地址是哪台主机

封装成帧就可以直接发送过去了

![](https://i0.hdslb.com/bfs/note/a844c6887c580e6326f145cb09331a440177a1ab.jpg@640w_!web-note.webp)

如果不知道也还是可以用ARP喊下街就好

目标主机收到包确认是自己的IP地址以后

解封查看段可以发现源和目标端口号

用目标端口号给到指定的应用程序

应用程序处理好以后

就可以按照源的信息做出响应

回去的原理也是一样的

现在你对OSI模型就应该有更具体的概念了