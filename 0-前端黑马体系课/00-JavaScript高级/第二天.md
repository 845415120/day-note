# 练习forEach和filter的案例

## 回顾forEach和filter

### forEach

```
// const array1 = ['a', 'b', 'c'];

const array1 = [
  { id: 1, uname: '宋江', nickname: '及时雨' }, 
  { id: 2, uname: '吴用', nickname: '智多星' }, 
  { id: 3, uname: '林冲', nickname: '豹子头' }
]

array1.forEach(item => {
  // console.log(item)
  console.log(item.uname)
});
```

forEach - 没有返回值，或者说返回值就是undefined。

### filter

filter - 过滤，所以，filter的作用是过滤(筛选)数组中的元素。

```
const array1 = [
  { id: 1, uname: '宋江', nickname: '及时雨' }, 
  { id: 2, uname: '吴用', nickname: '智多星' }, 
  { id: 3, uname: '林冲', nickname: '豹子头' }
]

const res = array1.filter(item => {
  // console.log(item)
  // console.log(item.uname)
  // return 条件
  return item.id >= 2
});

console.log(res) // res 是筛选的结果
```

## 案例中使用forEach

循环遍第1次，拼接一个div

- div中，使用第1个商品的图片、名称、价格

循环遍历第2次，拼接一个div  
div中，使用第2个商品的图片、名称、价格  
.........  
循环结束，拼接得到 8 个div，把拼接好的 8 个div放到 页面中即可。

```
// 封装一个函数（为了多次调用）
function render(data) {
  let str = ''
  data.forEach(item => {
    str += `
    <div class="item">
      <img src="${item.picture}" alt="">
      <p class="name">${item.name}</p>
      <p class="price">${item.price}</p>
    </div>
    `
  })
  // 循环结束，str 拼接成了 8 个 <div>
  // console.log(str)
  document.querySelector('.list').innerHTML = str
}

// 调用函数，渲染全部商品
render(goodsList)
```

## 案例中使用filter

```
// 2. 筛选 -------------------------------------------------
// 2.1) 找到4个按钮，注册单击事件
// let as = document.querySelectorAll('.filter a')
// for (let i = 0; i < as.length; i++) {
//   // 循环一次，注册一个事件；（结果是循环4次，注册了4个事件）
//   as[i].addEventListener('click', function () { })
// }
// 上述循环，分别注册事件，可以实现效果，但是注册的事件太多了，不科学。此类问题非常适合使用事件委托方案
document.querySelector('.filter').addEventListener('click', function (e) {
  // 2.2) 单击事件，函数内部进行筛选
  // 2.3) 获取每个 a 标签的 data-index 属性 （通过这个属性值，判断点击的是哪个a）
  if (e.target.tagName === 'A') {
    // 如果符合这个条件，说明用户点击了 a 标签
    // let index = 元素.dataset.index  // 元素.dataset = { index: 1 }
    let index = e.target.dataset.index
    // console.log(index) // 1  2  3  undefined
    // 2.4) 使用 filter 对原始数据 goodsList 进行筛选，得到筛选后的新数组
    let arr = []
    // index 的结果，是一个字符串类型的 1，所以下面的判断只能使用 ==，不能使用 ===
    if (index == 1) {
      arr = goodsList.filter(item => item.price <= 100)
    } else if (index == 2) {
      arr = goodsList.filter(item => item.price > 100 && item.price <= 300)
    } else if (index == 3) {
      arr = goodsList.filter(item => item.price > 300)
    } else {
      arr = goodsList
    }
    // 整个判断结束，得到筛选后arr数组
    // console.log(arr)
    // 2.5) 调用 render函数，将筛选后的数据渲染到页面
    render(arr)
  }
})
```

**这个案例多写几遍，后面还会用到** 。  

# 创建对象的三种方式

## 字面量对象（非常重要）

- 字面量的意思是，看字面意思，看结构就能知道它是什么类型
- 看到 `{}` 说明是对象，看到 `[]` 说明是数组，这就是字面量的意思
- 键**只能** 是 字符串或数字

- 字符串如果有 `-` ，则必须加引号
- 键如果是数字，一般都是伪数组

- 值可以是任意类型
- 访问对象的属性值

- **对象.属性**
- **对象['属性']** ------------ 键有 `-` 这样的特殊字符，**必须** 用这个语法
- **对象[变量]** ------------- 键用一个变量表示的，必须用方括号语法，并且变量不能加引号

```
let obj = {
  uname: 'zs',
  'user-name': 'lisi',
  age: 20,
  bb: {
    dname: '汪仔'
  },
  cc: ['琪琪', 'pink'],
  dd: null,
  ee: true,
  ff: function () { },
  gg: function () { },
}

// obj.属性
console.log(obj.uname)
// obj['属性']
console.log(obj['user-name'])
// obj[变量]
let a = 'age'
console.log(obj[a]) // 相当于是 obj['age']
```

## new Object创建对象（没什么用）

```
let obj = new Object()
console.log(obj); // {}  

let obj = new Object({ uname: 'zs', age: 20 })
console.log(obj); // { uname: 'zs', age: 20 }
```

## 通过构造函数创建对象

### 基本语法

```
// 构造函数，本质肯定也是函数（构造函数要求首字母大写）
function Pig(name, age, gender) {
  // 把对象的属性，放到构造函数内部，写一份即可
  // 把对象的所有属性，都加给 this
  this.name = name
  this.age = age
  this.gender = gender
}

// 通过构造函数，创建对象语法
// let 对象 = new 构造函数(参数, 参数, ....)
let Peppa = new Pig('佩奇', 6, '女')
let George = new Pig('乔治', 3, '男')
console.log(Peppa)
console.log(George)
```

### 实例化的过程

- new 构造函数() 叫做创建对象，也叫做实例化对象。
- let Peppa = new Pig() 得到的 Peppa 对象，也叫做实例对象

**实例化的过程** ：1. new Pig() 的时候，首先创建一个空对象  
2. 修改 构造函数内的this。 把this改为实例对象 (说明构造函数中的this表示实例对象)  
3.  执行构造函数里面的代码，给实例对象添加属性  
4. 返回创建好的对象  
![](https://cdn.nlark.com/yuque/0/2022/jpeg/22014993/1659845529830-57ae2e9b-0e44-4b95-ab04-6043c0a9f25c.jpeg)  

### 其他说明

- 构造函数中的返回值问题

- 正常来讲，构造函数中不需要返回值
- 如果构造函数中返回了一个原始类型值（字符串、数字、布尔），**无效** 。
- 如果构造函数中，返回了一个引用类型的值（对象），则结果就是返回的这个对象了。

```
function Pig() {
  this.name = '乔治'
  this.age = 3
  this.gender = '男'
  // return 'hello world' // 无效
  return { bookname: '遮天', author: '辰东' } // 构造函数中，返回一个对象，则实例化之后就会得到这个对象
}

let obj = new Pig()
console.log(obj) // {bookname: '遮天', author: '辰东'}
```

- `new Date()` 中的 `Date` 也是一个构造函数，只不过是内置的。
- 类似 `Date` 的构造函数，还有很多，比如 Array、String、Math、Object.......      

### 静态成员

给构造函数添加的属性或方法，叫做静态方法。  
静态方法只能通过构造函数来调用。  
我们曾经用过的 `Math.max()` 等就是静态方法。

```
function Pig() {
  // this是表示什么？实例对象
  this.name = '佩奇'   // 相当于 Peppa.name = '佩奇'
  this.age = 20       // 相当于 Peppa.age = 20
}

// 把构造函数也当做对象用，也是可以的，还是可以通过 【对象.属性】语法来添加属性或访问属性
// 给构造函数直接添加的属性，叫做静态属性
Pig.color = 'pink'   // 添加一个静态属性
Pig.say = function () {
  // 给Pig构造函数添加一个静态方法
  console.log('大家好，我是佩奇')
}
console.log(Pig.color) // pink
Pig.say()
```

# 内置构造函数介绍

## 引用类型

- Array
- Object
- RegExp
- Date
- .......      

## 包装类型

当把字符串、数字这种原始类型，当做对象使用的时候，**JS会自动包装他们，把他们包装成对象** ，然后再使用 【对象.xxx()】 这样的语法。比如：

```
// String/Number/Boolean
let str = 'hello'
// console.log(typeof str) // string

// str = new String('hello') // JS内部，自动 new String()，得到一个对象
// console.log(typeof str) // object

console.log(str.length)
console.log(str.toUpperCase())
```

- Number
- String
- Boolean
- ........      

# 数组方法(Array)

参考：[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)  

## forEach

## filter

## map(遍历并返回新数组)

遍历数组，map方法可以返回一个新数组。  
遍历原数组 --> 每次循环返回一个值 --> 循环结束得到很多个返回值。  
调用 map 的结果，就是有这些返回值组成的新数组。

```
// map ----------------------------------------------
let arr = [3, 4, 6, 9]
let res = arr.map(item => {
  // return '结果'
  return item * item
})
console.log(res) // [9, 16, 36, 81]
```

## some(一些)

根据给出的条件，判断数组中是否有元素符合条件。

- 如果有一个或几个元素符合条件，则返回 true
- 如果没有任何元素符合条件，则返回 false

```
// some --------------------------------------------
let arr = [3, 4, 6, 9]
let res = arr.some(item => {
  // return '条件'
  return item > 5  // 要求，只要数组中有元素 大于5，即可得到 true
})

console.log(res) // true
```

## every(每一个)

根据给出的条件，判断数组中是否所有元素都符合条件

- 所有元素都符合条件，则返回true
- 有任何一个元素不符合条件，都是返回false

```
// every --------------------------------------------
let arr1 = [3, 4, 6, 9]
let res1 = arr1.every(item => {
  // return '条件'
  return item > 5  // 要求，数组的每一个元素都 大于 5，才能得到true
})

console.log(res1) // false
```

## find(查找)

根据给出的条件，查找数组中的元素。

- 如果有符合条件的元素，则返回这个元素
- 如果有多个符合条件的元素，则返回找到的第1个元素，并终止查找
- 如果没有符合条件的元素，则返回 undefined

```
let arr = [100, 150, 230, 99, 500, 600]
let res = arr.find(item => {
  // return '条件'
  return item > 200
})
console.log(res) // 230，结果是第1个找到的元素
```

## findIndex(查找索引)

根据给出的条件，查找数组中的元素的下标。

- 如果有符合条件的元素，则返回这个元素的下标
- 如果有多个符合条件的元素，则返回找到的第1个元素的下标，并终止查找
- 如果没有符合条件的元素，则返回 `-1`

```
let arr = [100, 150, 230, 99, 500, 600]
let res = arr.findIndex(item => {
  // return '条件'
  return item > 200
})
console.log(res) // 2，结果是第1个找到的元素的下标
```

## reduce

作用：可以把数组的元素累加到一起。  
语法一：有初始值

```
let arr = [3, 7, 4, 6, 5]
// let sum = arr.reduce((总和, 当前元素) => { }, 初始值)
let sum = arr.reduce((total, curr) => {
  // 因为有初始值，所以起始的时候，total = 初始值100
  return total + curr  // 第1次循环 100 + 3 = 103  第2次循环 103 + 7 = 110 ...........
}, 100)
console.log(sum)
```

语法二：不给初始值

```
// reduce ----------------- 没有初始值 --------------
let arr = [3, 7, 4, 6, 5]
// let sum = arr.reduce((总和, 当前元素) => { }, 初始值)
let sum = arr.reduce((total, curr) => {
  // 因为[没有]初始值，所以【起始】的时候，【total = 第1个元素，也就是3】 【curr = 第2个元素，也就是7】
  return total + curr  // 第1次循环 3 + 7 = 10  第2次循环 10 + 4 = 14 ...........
})
console.log(sum)
```

## sort

排序

```
// ----------------- 基本认知 ---------------
// let arr = [3, 5]
// let res = arr.sort((a, b) => {
//   // a = 5  b = 3
//   // return 正数, 则不交换两个元素的位置
//   // return 负数, 则交换两个元素的位置
//   // return 0,什么都不做
//   return -2
// })
// console.log(res) // [5, 3]

// ---------------- 数字的排序 ---------------------
// 目标：实现从小到大排序
// let arr = [3, 5, 4, 8, 0, 2]
// let res = arr.sort((a, b) => {
//   // 第1次比较，a = 5; b = 3，这次不希望交换位置，则返回正数  a - b
//   // 第2次比较，a = 4; b = 5，这次希望交换位置，则返回负数 a - b
//   return a - b
// })
// console.log(res)

// ---------------- 复杂数字的排序 -------------------
// let arr = [
//   { uname: 'zs', age: 20 },
//   { uname: 'lisi', age: 30 },
//   { uname: 'wangwu', age: 10 },
//   { uname: 'pink', age: 40 },
// ]
// // 目标：按照年龄，从小到大排序（升序）
// let res = arr.sort((a, b) => {
//   // 第1次比较，a = { uname: 'lisi', age: 30 }   b = { uname: 'zs', age: 20 }
//   // 第1次比较，不希望交换位置。需要返回正数，怎么得到正数 a.age - b.age
//   return a.age - b.age
// })
// console.log(res)


// -------------- 按照英文字符或中文排序 --------------
// 中文、英文也有大小之分，按照 Unicode 编码进行大小比较的
// 世界上所有的字符（拉丁文、英文、中文、日文等等，包括符合），都对应着一个独一无二的Unicode编码
// 完整的Unicode编码：http://www.tamasoft.co.jp/en/general-info/unicode.html
// 中文的Unicode编码范围是 4e00 ~ 9fa5
// 按照姓名，从小到大排序
// let arr = [
//   { uname: 'zs', age: 20 },
//   { uname: 'lisi', age: 30 },
//   { uname: 'wangwu', age: 10 },
//   { uname: 'pink', age: 40 },
// ]
// let res = arr.sort((a, b) => {
//   // 第1次，a = { uname: 'lisi', age: 30 }; b = { uname: 'zs', age: 20 }
//   // 
//   if (a.uname < b.uname) return -1  // lisi < zs ，这种情况下，我们需要交换位置，所以才返回 -1
//   if (a.uname > b.uname) return 1
//   if (a.uname === b.uname) return 0
// })
// console.log(res)

// --------------------------- 打乱数组 ------------------------
let arr = [3, 5, 2, 8, 9, 7]
let res = arr.sort((a, b) => {
  return Math.random() - 0.5
})
console.log(res)
```

## reverse

翻转数组

```
let res = [2, 3, 4, 5].reverse()

console.log(res) // [5, 4, 3, 2]
```

## splice

从指定的位置(下标)，删除几个元素，并可以添加一些新元素。

```
// splice -- 删除指定的元素，并且可以添加新元素
// 语法： arr.splice(位置, 删除的数量, 新增的元素, 新增的元素, ........)
// 这个方法，直接修改原数组
let arr = ['宋江', '吴用', '林冲']
// --- 删除一个元素 ---
// arr.splice(1, 1) // 从下标1的位置，删除1个元素
// console.log(arr)
// --- 修改一个元素 ---
arr.splice(1, 1, '花荣')
console.log(arr) // ['宋江', '花荣', '林冲']
```

## unshift

向数组的开头添加新元素  

## push

向数组的末尾添加新元素  

## shift

从数组的开头删除一个元素  

## pop

从数组的末尾删除一个元素  

## includes

自己总结  

## indexOf

自己总结  

## slice

自己总结  

## Array.from()

将伪数组转成真数组

```
// Array.from -- 将伪数组，转成真数组（伪数组不能调用数组方法；转成真数组就可以调用数组方法了）
let lis = document.querySelectorAll('li') // 得到伪数组
// console.log(lis)
// lis.pop() // 报错，不能通过伪数组，调用数组方法
let arr = Array.from(lis)
arr.pop() // 移除数组中最后一个元素
console.log(arr)
```

## Array.isArray()

判断变量是否是真数组

```
// Array.isArray() -- 判断变量是否是数组
console.log(Array.isArray([])) // true
console.log(Array.isArray(['a', 'b'])) // true
let lis = document.querySelectorAll('li') // 得到伪数组
console.log(Array.isArray(lis)) // false
console.log(Array.isArray({ uname: 'zs' })) // false
```

# 字符串方法(String)

## split(分割)

将字符串分割为数组

```
let str = 'pink,琪琪,老段'

// ['pink', '琪琪', '老段']
// split ----------------- 根据指定的字符，将字符串分割为数组 ---------------------
let arr = str.split(',')
console.log(arr)
```

## substring(截取)

字符串截取

```
let str = 'pink,琪琪,老段'

// substring -------------- 字符串截取 ---------------------------------------
let res = str.substring(2) // 表示从下标2的位置开始截取，一直截取的结尾
console.log(res) // nk,琪琪,老段

let res2 = str.substring(2, 6) // 表示从下标2的位置开始截取，截取到下标6的位置(不包括6的位置)
console.log(res2) // nk,琪
```

## includes(包含)

判断字符串中是否包含 xxx。  
比如，判断 `hello world` 中 是否包含 `or` ，如果包含就返回true，否则返回false

```
// includes -- 判断字符串中是否包含某个字符，包括则返回true，不包含则返回false
console.log('hello'.includes('h')) // true
console.log('hello'.includes('ell')) // true
console.log('hello'.includes('ho')) // false
console.log('hello'.includes('h', 2)) // false 从2的位置往后数，看字符串中是否包含h
```

## startsWith(开头)

判断字符串的开头是什么

```
console.log('hello'.startsWith('h')) // true
console.log('hello'.startsWith('he')) // true
console.log('hello'.startsWith('hello')) // true
console.log('hello'.startsWith('e')) // false
console.log('hello'.startsWith('e', 1)) // true。从位置1开始算起，看这段字符串的开头是否是e
```

## endsWith(结尾)

判断字符串的结尾是什么

```
// endsWith -- 判断字符串的结尾是什么。如果是返回true，不是返回false
console.log('hello'.endsWith('llo')) // true
console.log('hello'.endsWith('ll', 4)) // true，4个长度，意思是先截取4个字符，然后看这4个字符的结尾是否是l
```

## toUpperCase(大写)

将字符串转为大写  

## toLowerCase(小写)

将字符串转为小写  

## trim(除空白)

去除字符串两边的空白

```
// trim() -- 去除字符串两边的空白
console.log('    hello   ')
console.log('    hello   '.trim())
```

## search(搜索)

在字符串中搜索什么

```
// search -- 在字符串中搜索字符。如果有这个字符，则返回第1个找到的位置；没有找到返回-1
console.log('hello'.search('e')) // 1
console.log('hello'.search('l')) // 2
console.log('hello'.search('a')) // -1
```

## replace(替换)

替换，比如将 `hello world` 中的 `o` 替换成 `m`

```
// console.log('this is a js'.replace('s', 'a')) // thia is a js // 只找第1个s，然后替换
console.log('this is a js'.replace(/s/g, 'a')) // thia ia a ja // 只找第1个s，然后替换
```

## slice

自己总结  

## indexOf

自己总结  

# 其他对象方法

## Number

### toFixed

去掉多余的小数（四舍五入，保留几位小数）

```
let num = 3.1415
console.log(num.toFixed(2)) // 3.14
console.log(num.toFixed(3)) // 3.142
```

### 精度问题

```
// 在浏览器控制台，计算 0.1 + 0.2 结果如下，出现了精度问题
0.1 + 0.2
0.30000000000000004
```

JS中，**使用小数计算的时候** ，经常会出现精度不准确的问题。这种问题，不是程序员的问题，是JS设计的问题。解决办法：

- 看看有几位小数，然后酌情乘以 10 或 100 或 1000 ....... ，把小数转成整数
- 然后计算整数
- 计算完成之后，再除以 10 或 100 或 1000 .......

所以，上述问题，可以这样计算：

```
// 先给 0.1 和 0.2 先乘以10，变为整数
// 把 1 和 2 相加
// 最后在除以 10
(0.1 * 10 + 0.2 * 10) / 10
0.3
```

## Object

这是一个静态方法，使用的时候，不用 `new`，也就是不用实例化对象，也就是不用创建对象。  
使用的时候，直接通过 【构造函数.方法()】 来使用即可，类似的方法有  `Math.max()`  

### Object.keys()

key - 键。keys方法的作用是获取对象的所有的键，结果是一个数组  

### Object.values()

value - 值，values方法的作用是获取对象的所有的值，结果也是一个数组

```
let obj = { uname: 'zs', age: 20, sex: '男' }

console.log(Object.keys(obj)) // ['uname', 'age', 'sex']
console.log(Object.values(obj)) // ['zs', 20, '男']
```

### Object.assign()

合并对象，可以用它来实现对象的（浅）拷贝。  
语法：

```
// 作用：用于合并对象
let obj1 = { name: 'zs', age: 20 }
let obj2 = { height: 180, weight: 80 }
// let obj3 = {}

// 作用：将 第2个参数、第3个参数，第.....个参数中的属性，合并到第1个参数中
// 语法一：
// Object.assign(obj3, obj1, obj2)
// console.log(obj3)

// 语法二：
// let obj = Object.assign({}, obj1, obj2)
// console.log(obj)


// 使用它，实现对象的拷贝
let obj = Object.assign({}, obj1)

// 拷贝之后，两个对象独立。（修改一个对象，另一个不受影响）
obj.name = 'lisi'

console.log(obj) // { name: 'lisi', age: 20 }
console.log(obj1) // { name: 'zs', age: 20 }


// 赋值
// let obj = obj1 ，如果是赋值的话，修改一个对象，另一个也受影响
```

# 购物车案例

## 循环遍历

循环遍历，完成初步的商品渲染：

```
let str = ''
goodsList.forEach(item => {
  str += `
  <div class="item">
    <img src="${item.picture}" alt="">
    <p class="name">${item.name} <span class="tag">【赠品】10优惠券</span></p>
    <p class="spec">白色/10寸</p>
    <p class="price">${item.price}</p>
    <p class="count">x${item.count}</p>
    <p class="sub-total">0000.80</p>
  </div>
  `
})
// 循环结束之后，得到 4 个 <div>
// console.log(str)
document.querySelector('.list').innerHTML = str
```

## 处理SKU

SKU 就是商品的信息，比如 白色，38码，XL，一箱.......

```
// 比如，某个商品的 SKU 如下
let spec = { size: '小号', color: '紫色' }   // 小号/紫色
console.log(Object.values(spec)) // ['小号', '紫色']
console.log(Object.values(spec).join('/')) // 小号/紫色
```

应用到案例中：

```
goodsList.forEach(item => {
+ // 循环的时候，拼接div之前，先把 SKU 处理好
+ let sku = Object.values(item.spec).join('/')
  str += `
  <div class="item">
    <img src="${item.picture}" alt="">
    <p class="name">${item.name} <span class="tag">【赠品】10优惠券</span></p>
+   <p class="spec">${sku}</p>
    <p class="price">${item.price}</p>
    <p class="count">x${item.count}</p>
    <p class="sub-total">0000.80</p>
  </div>
  `
})
```

## 处理赠品

单独研究，赠品的处理

```
let gift = '50g茶叶,清洗球'
// 将字符串转成数组
// let arr = gift.split(',')
// // console.log(arr) // ['50g茶叶', '清洗球']

// let res = arr.map(item => {
//   return `<span class="tag">【赠品】${item}</span>`
// })

// // console.log(res) // ['<span class="tag">【赠品】50g茶叶</span>', '<span class="tag">【赠品】清洗球</span>']

// console.log(res.join(''))

console.log(gift.split(',').map(item => `<span class="tag">【赠品】${item}</span>`).join(''))
```

应用到案例中：

```
goodsList.forEach(item => {
  // 循环的时候，拼接div之前，先把 SKU 处理好
  let sku = Object.values(item.spec).join('/')
+ // 处理商品的赠品
+ let zengpin = item.gift ? item.gift.split(',').map(item => `<span class="tag">【赠品】${item}</span>`).join('') : ''
  str += `
  <div class="item">
    <img src="${item.picture}" alt="">
+   <p class="name">${item.name} ${zengpin}</p>
    <p class="spec">${sku}</p>
    <p class="price">${item.price}</p>
    <p class="count">x${item.count}</p>
    <p class="sub-total">0000.80</p>
  </div>
  `
})
```

## 处理每个商品的小计

```js
goodsList.forEach(item => {
  // 循环的时候，拼接div之前，先把 SKU 处理好
  let sku = Object.values(item.spec).join('/')
  // 处理商品的赠品
  let zengpin = item.gift ? item.gift.split(',').map(item => `<span class="tag">【赠品】${item}</span>`).join('') : ''
+ // 处理每件商品的小计（第1次循环，使用单价 * 数量 ； 第2次循环 ....................）
+ let xiaoji = item.price * item.count
  str += `
  <div class="item">
    <img src="${item.picture}" alt="">
    <p class="name">${item.name} ${zengpin}</p>
    <p class="spec">${sku}</p>
    <p class="price">${item.price}</p>
    <p class="count">x${item.count}</p>
+   <p class="sub-total">${xiaoji.toFixed(2)}</p>
  </div>
  `
})
```

## 合计

为了避免计算精度文档，所以先将商品的单击 * 100，变为整数。  
计算结束，在 除以 100，恢复回来。

```js
// 合计
// 使用 reduce 数组方法，累加每个商品的价格 (单价 * 数量)
let sum = goodsList.reduce((total, curr) => {
  // 给了初始值，所以起始的时候，total = 0   curr表示第1个商品
  return total + curr.price * 100 * curr.count
}, 0)

document.querySelector('.amount').innerHTML = (sum / 100).toFixed(2)
```