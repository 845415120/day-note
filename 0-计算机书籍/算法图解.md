---
时间: 2023-11-17
标题: 算法图解
图片: https://img9.doubanio.com/view/subject/s/public/s29358625.jpg
链接: https://book.douban.com/subject/26979890/
tags:
  - 算法
评价: 9.9★★★★★
---

# 数组与链表
![|500](Pasted%20image%2020231117123218.png)

## 数组链表

![|500](Pasted%20image%2020231117123045.png)


# 选择排序
![](Pasted%20image%2020231117123132.png)
# 递归

![|600](Pasted%20image%2020231117123419.png)

### 循环是一种方法

![|600](Pasted%20image%2020231117123445.png)

### 递归另一种方法

![|500](Pasted%20image%2020231117123537.png)

这两种方法的作用相同，但在我看来，第二种方法更清晰。递归只是让解决方案更清晰，并 没有性能上的优势。实际上，在有些情况下，使用循环的性能更好。我很喜欢Leigh Caldwell在Stack Overflow上说的一句话：“如果使用循环，程序的性能可能更高；如果使用递归，程序可能 更容易理解。如何选择要看什么对你来说更重要。
## 基线条件和递归条件
![](Pasted%20image%2020231117124016.png)
编写递归函数时，必须告诉它何时停止递归。正因为如此，每个递归函数都有两部分：**基线 条件**（base case）和**递归条件**（recursive case）。

![|500](Pasted%20image%2020231117124030.png)

# 栈

这种数据结构称为栈。栈是一种简单的数据结构
![](Pasted%20image%2020231117124306.png)
## 调用栈

计算机在内部使用被称为调用栈的栈
![|500](Pasted%20image%2020231117124606.png)

每当你调用函数时，计算机都像这样将函数调用涉及的所有变量的值存储到内存中。接下来， 你打印hello, maggie!，再调用greet2("maggie")。同样，计算机也为这个函数调用分配一 块内存

![|500](Pasted%20image%2020231117124638.png)
## 递归调用栈

递归函数也使用调用栈！来看看递归函数factorial的调用栈。factorial(5)写作5!，其 定义如下：5! = 5 * 4 * 3 * 2 * 1。同理，factorial(3)为3 * 2 * 1。下面是计算阶乘的递归函数。 
```
def fact(x):
if x == 1: 
return 1 else:
return x * fact(x-1)
```

![|500](Pasted%20image%2020231117124728.png)

![|550](Pasted%20image%2020231117124752.png)

# 快速排序

  **分而治之 （divide and conquer，D&C）——一种著名的递归式问题解决方法**

**重要的D&C算法——快速排序**

使用D&C解决问题的过程包括两个步骤。

(1) 找出基线条件，这种条件必须尽可能简单。 

(2) 不断将问题分解（或者说缩小规模），直到符合基线条件。

![](Pasted%20image%2020231117130949.png)

# _散列表_（_Hash_ table，也叫哈希表）

![|300](Pasted%20image%2020231117132616.png)

散列表适合用于： 

 模拟映射关系； 

 防止重复；

 缓存/记住数据，以免服务器再通过处理来生成它们。

你可以结合散列函数和数组来创建散列表。

## 冲突

 冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。 

处理冲突的方式 很多，最简单的办法如下：如果两个键映射到了同一个位置，就在这个位置存储一个链表。

![](Pasted%20image%2020231117132913.png)


##  散列表的查找、插入和删除速度都非常快。

![](Pasted%20image%2020231117133106.png)


 散列表适合用于模拟映射关系。 

 一旦填装因子超过0.7，就该调整散列表的长度。

 散列表可用于缓存数据（例如，在Web服务器上）。

 散列表非常适合用于防止重复。

# 广度优先搜索

 **广度优先搜索 用来解决最短路径问题的算法**
 
## 广度优先搜索可回答两类问题。

 第一类问题：从节点A出发，有前往节点B的路径吗？（在你的人际关系网中，有芒果销 售商吗？） 

 第二类问题：从节点A出发，前往节点B的哪条路径最短？（哪个芒果销售商与你的关系 最近？）

假设你居住在旧金山，要从双子峰前往金门大桥。你想乘公交车前往，并希望换乘最少。可 乘坐的公交车如下。

![](Pasted%20image%2020231117133626.png)

# 实现算法
![](Pasted%20image%2020231117140912.png)

![](Pasted%20image%2020231117141101.png)

# 狄克斯特拉算法

## 步骤。

(1) 找出“最便宜”的节点，即可在最短时间内到达的节点。
![|500](Pasted%20image%2020231117141211.png)
(2) 更新该节点的邻居的开销，其含义将稍后介绍。 
![|500](Pasted%20image%2020231117141258.png)
(3) 重复这个过程，直到对图中的每个节点都这样做了。 

(4) 计算最终路径。


**广度优先搜索来查找两点之间的最短路径，那时“最短路径”的意思是 段数最少。**

**在狄克斯特拉算法中，你给每段都分配了一个数字或权重，因此狄克斯特拉算法找出 的是总权重最小的路径**

狄克斯特拉算法背后的关键理念：找出图中最便宜的节点，并确保没有到该节点的更 便宜的路径

## 代码实现

![](图解算法.pdf)

# 贪心算法

贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。

 对于NP完全问题，还没有找到快速解决方案。

 面临NP完全问题时，最佳的做法是使用近似算法。

 贪婪算法易于实现、运行速度快，是不错的近似算法。


## 背包问题

![|100](Pasted%20image%2020231117143731.png)   

(1) 盗窃可装入背包的最贵商品。

(2) 再盗窃还可装入背包的最贵商品，以此类推。

在有些情况下，完美是优秀的敌人。有时候，你只需找到一 个能够大致解决问题的算法，此时贪婪算法正好可派上用场，因为它们实现起来很容易，得到的 结果又与正确结果相当接近

## 集合覆盖问题

假设你办了个广播节目，要让全美50个州的听众都收听得到。为 此，你需要决定在哪些广播台播出。在每个广播台播出都需要支付费 用，因此你力图在尽可能少的广播台播出。现有广播台名单如下

每个广播台都覆盖特定的区域，不同广播台的覆盖区域可能重叠

![|300](Pasted%20image%2020231117144002.png)
如何找出覆盖全美50个州的最小广播台集合呢？听起来很容易，但其实非常难。具体方法如下。

(1) 列出每个可能的广播台集合，这被称为幂集（power set）。可能的子集有2^n 个。

(2) 在这些集合中，选出覆盖全美50个州的最小集合。

问题是计算每个可能的广播台子集需要很长时间。由于可能的集合有2n 个，因此运行时间为 O(2n )。如果广播台不多，只有5～10个，这是可行的。但如果广播台很多，结果将如何呢？随着 广播台的增多，需要的时间将激增。假设你每秒可计算10个子集，所需的时间将如下。

贪婪算法可化解危机！使用下面的贪婪算法可得到非常接近的解。

(1) 选出这样一个广播台，即它覆盖了最多的未覆盖州。即便这个广播台覆盖了一些已覆盖 的州，也没有关系。 

(2) 重复第一步，直到覆盖了所有的州。

这是一种近似算法（approximation algorithm）。

在获得精确解需要的时间太长时，可使用近 似算法。判断近似算法优劣的标准如下：

 速度有多快； 

 得到的近似解与最优解的接近程度。
贪婪算法 的运行时间为O(n2 )，其中n为广播台数量。

## NP 完全问题

旅行商问题和集合覆盖问题有一些共同之处：你需要计算所有的解，并从中选出最小/最短 的那个。这两个问题都属于NP完全问题。

NP完全问题的简单定义是，以难解著称的问题，如旅行商问题和集合覆盖问题。很多非常 聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。



# 动态规划

## 背包问题

使用动态规划！下面来看看动态规划算法的工作原理。

动态规划先解决子问题，再逐 步解决大问题

**对于背包问题，你先解决小背包（子背包）问题，再逐步解决原来的问题**

![|500](Pasted%20image%2020231117145511.png)

动态规划是一个难以理解的概念，如果你没有立即搞懂

先来演示这种算法的执行过程。看过执行过程后，你心里将有一大堆问题！我将竭尽所能解 答这些问题。

每个动态规划算法都从一个网格开始，背包问题的网格如下

![|500](Pasted%20image%2020231117151930.png)

网格的各行为商品，各列为不同容量（1～4磅）的背包。所有这些列你都需要，因为它们将 帮助你计算子背包的价值。
通过前面的动态规划问题，你得到了哪些启示呢？

 动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必 须在背包容量给定的情况下，偷到价值最高的商品。

 在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。 要设计出动态规划解决方案可能很难，这正是本节要介绍的。下面是一些通用的小贴士。

 每种动态规划解决方案都涉及网格

单元格中的值通常就是你要优化的值。在前面的背包问题中，单元格的值为商品的价值。 

 每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网 格的坐标轴
## 最长公共子串



## 费曼算法

![|100](Pasted%20image%2020231117153506.png)

(1) 将问题写下来。

(2) 好好思考。

(3) 将答案写下来。

## 动态规划都有哪些实际应用呢？

 生物学家根据最长公共序列来确定DNA链的相似性，进而判断度两种动物或疾病有多相 似。最长公共序列还被用来寻找多发性硬化症治疗方案。

 你使用过诸如git diff等命令吗？它们指出两个文件的差异，也是使用动态规划实现的。

 前面讨论了字符串的相似程度。编辑距离（levenshtein distance）指出了两个字符串的相 似程度，也是使用动态规划计算得到的。编辑距离算法的用途很多，从拼写检查到判断 用户上传的资料是否是盗版，都在其中。

 你使用过诸如Microsoft Word等具有断字功能的应用程序吗？它们如何确定在什么地方断 字以确保行长一致呢？使用动态规划

# K最近邻算法

K 最近邻（k-nearest neighbours，KNN）算法

![](Pasted%20image%2020231117153947.png)

## KNN算法 与 机器学习

KNN算法真的是很有用，堪称你进入神奇的机器学习领域的 领路人！机器学习旨在让计算机更聪明。你见过一个机器学习的 例子：创建推荐系统。下面再来看看其他一些例子。

### OCR

OCR指的是光学字符识别（optical character recognition），这意味着你可拍摄印刷页面的照片， 计算机将自动识别出其中的文字。Google使用OCR来实现图书数字化。OCR是如何工作的呢？我 们来看一个例子。请看下面的数字。

### 垃圾邮件过滤器

垃圾邮件过滤器使用一种简单算法——朴素贝叶斯分类器（Naive Bayes classifier），你首先 需要使用一些数据对这个分类器进行训练。

# 树

# 傅里叶变换

绝妙、优雅且应用广泛的算法少之又少，傅里叶变换算是一个。

Better Explained是一个杰出 的网站，致力于以通俗易懂的语言阐释数学

傅里叶变换非常适合用于处理信号，可使用它来压缩音乐

傅里叶变换能够准确地指出各个音符对整个歌曲的 贡献，让你能够将不重要的音符删除。这就是MP3格式的工作原理

数字信号并非只有音乐一种类型。JPG也是一种压缩格式，也采用了刚才说的工作原理。傅 里叶变换还被用来地震预测和DNA分析。

使用傅里叶变换可创建类似于Shazam这样的音乐识别软件。傅里叶变换的用途极其广泛，你 遇到它的可能性极高！