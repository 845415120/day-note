# 继承

![](https://cdn.staticaly.com/gh/845415120/picx-images-hosting@master/20230811/8c4c0b8cace7fb269ff4015fc8e1c2f6ec2519aed517ca0f02dc57095e7145a2.21a5uvyco4e8.webp)

### 原型链继承

![](https://cdn.staticaly.com/gh/845415120/picx-images-hosting@master/20230811/deb24087b288e570dd4a3bf82a2427c751935a875ccbb04dd9140a20ca2a5b69.5lno3b9sl8w0.webp)

 Child.prototype = new Parent();

### 构造函数继承

- 借助 call调用Parent函数

### 组合继承

一方面在子类的构造函数中通过call()函数调用父类的构造函数，将父类的实例的属性和函数绑定到子类的this中；

另一方面，通过改变子类的prototype属性，继承父类的原型对象上的属性和函数。

Object.create() 静态方法以一个现有对象作为原型，创建一个新对象。浅拷贝



# 原型链继承

原型链继承的主要思想是：重写子类的prototype属性，将其指向父类的实例。

我们定义一个子类Cat，用于继承父类Animal，子类Cat的实现代码如下

```jsx
// 子类Cat
function Cat(name) {
   this.name = name;
}
// 原型继承
Cat.prototype = new Animal();
// 很关键的一句，将Cat的构造函数指向自身
Cat.prototype.constructor = Cat;
//因为如果不将Cat原型对象的constructor属性指向自身的构造函数的话，那将会指向父类Animal的构造函数。
//Cat.prototype.constructor === Animal; // true
//所以在设置了子类的prototype属性后，需要将其constructor属性指向Cat。
var cat = new Cat('加菲猫');
console.log(cat.type);    // Animal
console.log(cat.name);    // 加菲猫
console.log(cat.sleep()); // 加菲猫正在睡觉！
console.log(cat.eat('猫粮'));  // 加菲猫正在吃：猫粮
```
