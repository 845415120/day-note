---
时间: 11分
作者: "\r技术蛋老师"
标题: JavaScript原型对象
图片: https://i1.hdslb.com/bfs/archive/55bd40c5ebb77d5a82912672b625ee821061cf74.jpg@480w_300h_1c_!web-space-channel-video.webp
链接: https://www.bilibili.com/video/BV117411v76o
评价: ★★★★★
---
# 原型prototype

- 每个函数都有prototype属性
- 对象都有__proto__属性指向函数原型对象prototype,
- 原型对象都会增加一个constructor属性,指向prototype属性所在的函数,即**构造函数**

![](https://cdn.staticaly.com/gh/845415120/picx-images-hosting@master/20230811/dc3cbdc186706de5b69f6aa30f3949ece4939a9c8d9d4ce3b9b397a58c3b4297.3ye5fxggehk0.webp)

- 所有对象都是继承至母体Oject 
- 函数都继承自Function
- 他们是在引擎中创建好的



原型对象

- 任何函数都有原型对象，当然构造函数也不例外，内置构造函数也不例外

- 原型对象由系统分配

- 通过 【构造函数.prototype】这样的语法，即可找到构造函数的原型对象

- 将构造函数中的方法定义到原型对象上，即可解决浪费内存的问题

- 构造函数 和 原型对象中的 this 都指向 实例对象

示例代码：

```
function Pig(name, age) {
  // this 表示实例对象
  this.name = name // obj.name = '佩奇'
  this.age = age
}
```

// 任何一个函数(普通函数、构造函数、内置的Array、String)，都有原型对象// 原型对象由系统分配，不用程序员手动加// console.dir() 也是输出内容，而且输出后，可以展开，看到内部的结果// console.dir(Pig) // Pig.prototype 就是Pig的原型对象// 把构造函数中的 eat、say方法，加给原型对象Pig.prototype.say = function () { console.log('会说话')}

Pig.prototype.eat = function () { console.log('会吃饭')}

let obj1 = new Pig('佩奇', 2)let obj2 = new Pig('乔治', 3)let obj3 = new Pig('老段', 4)console.log(obj1)console.log(obj2)console.log(obj3)</code></pre>

图示：  
![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660031058940-68f2cc1d-40a5-4e26-90e1-d082754b53c9.png#averageHue=%23f9f8f8&clientId=u8d4b4a46-00ac-4&from=paste&height=462&id=u7eaf6f88&originHeight=578&originWidth=816&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35407&status=done&style=none&taskId=uc3d8f946-08fb-4aba-9c27-13078937024&title=&width=652.8)  
**结论** ：**所有对象的属性，放到构造函数中，所有的方法都加给原型对象** 。


# 三角关系

面向对象中，经常提及 **构造函数** 、**原型对象** 、**实例对象** 。那么三者之间有什么关系呢？  
内置的Array来说明，图示如下：  
![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660034740643-fb9a9996-38d1-4741-ad57-6ac532c662b1.png#averageHue=%23faf9f8&clientId=u8d4b4a46-00ac-4&from=paste&height=315&id=u650957e3&originHeight=394&originWidth=821&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43252&status=done&style=none&taskId=u03d15fad-f7fe-482f-b0a2-a186e5c3295&title=&width=656.8)  
拿自定义的Pig函数来说，图示如下：  
![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660034961413-74bf41d0-7233-4312-b650-06d966c04bd8.png#averageHue=%23faf9f9&clientId=u8d4b4a46-00ac-4&from=paste&height=323&id=u03da8f72&originHeight=404&originWidth=783&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42003&status=done&style=none&taskId=uefb6ceab-ff18-48b3-b069-cf80e08d1a2&title=&width=626.4)

其实，实例对象的 [[Prototype]] 属性才指向 原型对象  
只不过，[[Prototype]] 是隐藏属性，不可访问，所以浏览器才实现了 __proto__ ，用于访问原型对象  
但是， __proto__ 是JS非标准属性，并且可能会被遗弃。  
建议使用 Object.getPrototypeOf(实例对象) 语法，来找原型对象。  
课堂代码：

```
// 声明构造函数
function Pig(name, age) {
  this.name = name
  this.age = age
}
```

// 向原型对象上加方法Pig.prototype.say = function () { }Pig.prototype.eat = function () { }

console.log(Pig.prototype.constructor) // Pig是构造函数；Pig.prototype找到原型对象；再点constructor再次找到构造函数

// 实例化let obj = new Pig('佩奇', 3)

console.log(obj.**proto**) // 通过实例对象，找到原型对象（非标准的，不建议用）console.log(Object.getPrototypeOf(obj)) // 通过该语法，找到原型对象（标准语法）

console.log(obj)</code></pre>

# 原型继承

通过**修改构造函数的原型对象** ，可以实现对象的继承。  
![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660037120309-12263782-1d52-46df-9f07-8d7c7a2b12f1.png#averageHue=%23fbfafa&clientId=u8d4b4a46-00ac-4&from=paste&height=509&id=u874a1aa4&originHeight=636&originWidth=1239&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112566&status=done&style=none&taskId=u0ff87942-1e5a-4209-b45e-c2bc818a4fc&title=&width=991.2)

通过原型继承后，需要手动修改原型对象的 constructor 属性。否则就不符合上述的三角关系了。 只要修改了原型对象，就得手动 指定 constructor 属性。 **固定语法** 构造函数.prototype.constructor = 构造函数

示例代码：

```
// -------------------------- Animal ---------------------------
function Animal() {
```

}Animal.prototype.eat = function () { console.log('会吃饭')}let a = new Animal()

// -------------------------- Pig ------------------------------function Pig() {

}Pig.prototype = a // 【关键】修改Pig的原型对象 为 a// 【关键】只要修改了原型对象，必须重置 constructor才行（否则三角关系就乱了）Pig.prototype.constructor = Piglet p = new Pig()

// 因为修改了Pig的原型对象 === Animal的实例对象，所以实例对象 p 就继承了a的方法、属性等等p.eat() // p对象，可以直接使用原型对象的原型对象上的方法，体现了继承

console.log(Pig.prototype.constructor)</code></pre>

# 原型链

原型链研究的是 对象属性的 查找机制。  
理解起来，并不是太难。

- 实例对象 有原型对象

- 原型对象也是对象，那也有原型对象..............

- 这样就形成了多层继承了

![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660038983232-4a55e293-5023-4da0-90f1-3ebf425262c8.png#averageHue=%23fcfbfb&clientId=u8d4b4a46-00ac-4&from=paste&height=537&id=u56dae5a3&originHeight=671&originWidth=1106&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55796&status=done&style=none&taskId=uc094666d-f878-4fe3-aa36-c3569208446&title=&width=884.8)  
**概念** ：  
基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为**原型链 (** 面试爱问**)**  
**对象属性(或方法)查找机制** ：

- 当查找对象的某个属性（包括方法）时，优先从当前对象自身中查找。

- 当做对象中没有该属性，则向上层原型对象中查找

- 如果原型对象中也没有该属性则继续向上层原型对象中查找

- .....................

- 一直找到最顶层为止。找到则使用该属性值，找不到则得到 undefined Object.prototype 是最顶层的原型对象。 Array、String等的原型对象的原型对象也是它

# instanceof 运算符

语法：

```
实例对象 instanceof 构造函数
```

比如：// 检测 p 的原型链上，是否有这个构造函数console.log(p instanceof Pig) // p的原型链上，有Pig这个构造函数，则返回trueconsole.log(p instanceof Animal) // p的原型链上，有Animal这个构造函数，则返回trueconsole.log(p instanceof Object) // p的原型链上，有Object这个构造函数，则返回true

console.log(p instanceof String) // p的原型链上，没有String这个构造函数，则返回false</code></pre>

作用：  
instanceof 运算符用于检测 实例对象的原型链上，是否有语法中给出的构造函数。



# 原型链

每个函数都有 prototype 属性 该属性指向原 型。

每个对象都有 `__proto__` 属性，指向了创建该对象的构造函数的原型。

对象可以通过 `__proto__ `来寻找不属于该对象的属性，` __proto__ `将对象连接起来组 成了原型链。

![](https://cdn.staticaly.com/gh/845415120/picx-images-hosting@master/20230811/image.5n0i9jte7qg0.webp)