## 浅拷贝

for 循环复制 改变初始引用对象, 复制的对象也会改变 两个地址,一个对象

    let obj2 = Object.assign({},obj1)

## 深拷贝

递归复制 就是两个对象

```js
  //通过 JSON.stringify 将上述对象先转为 JSON 字符串  
    let str = JSON.stringify(obj1)  
    // console.log(str)  
    // 把 str 字符串，转成对象  
    let obj2 = JSON.parse(str)
```

## 直接赋值

赋值，就是一个 = ，比如 `let obj2 = obj1` 这就是赋值。![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660101207813-a3304ba6-62ca-4e2e-9321-b5ee93a8bfdc.png#averageHue=%23f9f8f8&clientId=u0c534017-63cf-4&from=paste&height=287&id=ucaf2bba3&originHeight=359&originWidth=672&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16736&status=done&style=none&taskId=u0eeefb57-5d6b-4291-9a3d-aa7885ee2ac&title=&width=537.6)  
总结：

- 原始类型（字符串、数字....）的值，直接赋值之后。只是把存储的值赋值给变量。赋值之后，两个变量互不影响。
- 引用类型（数组、对象）的值，因为存储的是地址，等号赋值之后，是把地址赋值给了另一个变量。修改其中一个对象的属性，另一个对象也跟着改了。      

## 浅拷贝

拷贝，就是把两个对象，完全的分开。  
目标：修改一个对象，另一个对象不受影响才行。  
**自己写循环，实现拷贝** ：

```js
let obj1 = {
  name: 'zs',
  age: 20,
  height: 180
}

let obj2 = {} // 写了这一行，已经表示 obj2 和 obj1 是两个不同的对象了
// obj2.name = 'zs'
// obj2.age = 20
// 循环遍历 obj1，循环一次，取obj1里面的一个属性，然后给obj2加上
for (let key in obj1) {
  // key 是 name、age、height
  // obj1[key] 是 zs、20、180
  // console.log(obj1[key]) // key是变量，必须用[]语法，而且绝对不能加引号
  obj2[key] = obj1[key]
}

// 尝试修改其中一个对象
obj1.age = 10000

console.log(obj1)
console.log(obj2)
```

问题：如果obj1里面有引用类型的值，代码如下：

```js
let obj1 = {
  name: 'zs',
  age: 20,
  height: 180,
+ info: {
+   sex: '男',
+   weight: 70
+ }
}
```

拷贝之后，图示如下：  
![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660103822611-6676e83e-5d01-40e1-bbc9-d03952c1a674.png#averageHue=%23f7f6f6&clientId=u23622dbb-8c57-4&from=paste&height=237&id=u308ecc78&originHeight=296&originWidth=897&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28587&status=done&style=none&taskId=u4254c808-9f3a-47dc-bab1-4e2c2b3dde5&title=&width=717.6)  
**像这样，只关注对象的第1层，只拷贝对象第1层的属性和属性值，这样的拷贝，就叫做浅拷贝** 。  

## 递归函数

本质上，也是函数。  
在函数内部，调用函数自身，这样的调用，叫做递归。  
**注意事项** ：
1. 在函数中调用它自己，这就是递归  
2.  写递归函数的时候，**必须设置一个终止条件（出口），否则就会形成死循环**  
**基本示例** ：

```js
// 1. 在函数中调用它自己，这就是递归
// 2. 写递归函数的时候，必须设置一个终止条件（出口），否则就会形成死循环

let i = 1
function fn() {
  // 如果i>10，利用return终止函数执行的特点。（这里并不是要返回一个值）
  if (i > 10) return
  console.log(i)
  i++
  // 在当前函数中，继续调用它自己，这样就形成了递归
  **fn()**
}

fn()
```

**案例：计算一个数的阶乘** ：

```
5的阶乘 = 5 * 4 * 3 * 2 * 1
10的阶乘 = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
```

```js
// 计算一个数的阶乘 ------------------------------------------------------
// 5的阶乘 = 5 * 4 * 3 * 2 * 1
// 10的阶乘 = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
// 写递归第1步，找规律。
// 规律：n的阶乘 = n * (n-1)的阶乘
// 写递归的第2步，明确函数的功能
// 接下来，写一个函数，函数的功能是计算一个数的阶乘（当我需要计算一个数的阶乘的时候，就调用这个函数）
// 写递归的第3步：相信自己

function fn(n) {
  // 如果n是1，则直接返回1
  if (n === 1) return 1
  // return n的阶乘
  return n * fn(n - 1)
}

console.log(fn(5))
console.log(fn(10))
```

**案例：计算斐波那契数列** ：

```js
位置：1  2  3  4  5  6  7  8  9 ....................... 40
数字：1  1  2  3  5  8  13 21 34 ...................... ??
// 第1位和第2位的数字，始终是1，不变
// 从第3位数字开始，数字 = 前一个数字 + 前前一个数字
```

```js
// ---------------------------------------------------------------------------
// 位置：1  2  3  4  5  6  7  8  9 .......................40
// 数字：1  1  2  3  5  8  13 21 34 ...................... ??
// 第1位和第2位的数字，始终是1，不变
// 规律：从第3位数字开始，数字 = 前一个数字 + 前前一个数字
// 规律：n位置的数字 = (n-1)位置的数字 + (n-2)位置的数字
// 写一个函数，功能是： 计算某个位置的数字 ，所以当我需要计算某个位置的数字时，就调用函数

function fn(n) {
  if (n === 1 || n === 2) return 1
  // return n-1位置的数字 + n-2位置的数字
  return fn(n - 1) + fn(n - 2)
}

console.log(fn(7)) // 13
console.log(fn(9)) // 34
console.log(fn(40)) // 102334155
```

## 深拷贝

**概念** ：深拷贝，通过递归，逐层将对象的属性、属性值拷贝给另一个对象，使得两个对象能够完全分开。

```js
let obj1 = {
  name: 'zs',
  age: 20,
  info: ['男', 180, 70],
  dog: {
    name: '旺财',
    color: 'black',
    child: {
      name: '小旺财',
      color: '花'
    }
  }
}


// 前提：
// 1. 准备好 需要拷贝的对象、或者数组
// 2. 准备好 一个空对象、或者空数组

// 拷贝的时候：
// 1. 先判断拷贝的值是数组吗
// 2. 再判断拷贝的值是对象吗
// 3. 不是数组，也不是对象，肯定是一个普通值，则直接拷贝

let obj2 = {}

// 相信自己，写一个函数，可以实现浅拷贝 （当我需要浅拷贝的时候，就调用这个函数）
function fn(obj1, obj2) {
  for (let key in obj1) {
    // 循环的时候，先判断，参见上面的 1、 2
    if (Array.isArray(obj1[key])) {
      obj2[key] = []
      // 现在，又需要把 obj1.info 里面的值，拷贝给 obj2.info 这个空数组
      // 这又是一个浅拷贝，当我需要浅拷贝的时候，就调用 fn 即可
      fn(obj1[key], obj2[key])
    } else if (obj1[key] instanceof Object) {
      obj2[key] = {}
      fn(obj1[key], obj2[key])
    } else {
      // 如果进入else，说明对象的值是普通的值，则直接拷贝
      obj2[key] = obj1[key]
    }
  }
}

fn(obj1, obj2)

// 尝试修改一个值
obj1.dog.color = '绿色'

console.log(obj1)
console.log(obj2)
```

## 其他拷贝方案

上述使用 `for (let key in obj) {}`  这样的语法实现的浅拷贝、深拷贝等等，讲解的主要目的是为了说明浅拷贝和深拷贝的概念。另外也可以增强编程能力。实际工作中，肯定不会写递归实现深拷贝。  
下面介绍其他拷贝的方案：

- Object.assign() ---- 本意是实现对象的合并，但是可以用于实现对象的 **浅** 拷贝。

```js
let obj1 = {
  name: 'zs',
  age: 20,
  dog: {
    name: '旺财',
    color: 'black'
  }
}

let obj2 = Object.assign({}, obj1)

obj2.name = 'lisi' // 修改对象第1层的属性值，另一个对象不受影响
obj2.dog.name = '小黑' // 修改对象第2层的属性值，另一个对象也跟着改了，说明是浅拷贝

console.log(obj1)
console.log(obj2)
```

- JSON.parse 和 JSON.stringify （注意：JSON中不能出现函数、undefined、但是可以实现深拷贝）

```js
let obj1 = {
  name: 'zs',
  age: 20,
  dog: {
    name: '旺财',
    color: 'black'
  },
  say: function () {
    console.log(123)
  }
}

// 通过 JSON.stringify 将上述对象先转为 JSON 字符串
let str = JSON.stringify(obj1)
// console.log(str)
// 把 str 字符串，转成对象
let obj2 = JSON.parse(str)

obj1.name = 'lisi'
obj1.dog.name = '小黑'

console.log(obj1)
console.log(obj2)
```

- 使用 前端知名的库 lodash 实现深、浅拷贝

```
<script src="./lodash.min.js"></script>
<script>
  let obj1 = {
    name: 'zs',
    age: 20,
    dog: {
      name: '旺财',
      color: 'black'
    },
    say: function () {
      console.log(123)
    }
  }

  // 浅拷贝
  // let obj2 = _.clone(obj1)

  // 深拷贝
  let obj2 = _.cloneDeep(obj1)


  obj1.name = 'lisi'
  obj1.dog.name = '小黑'
  console.log(obj1)
  console.log(obj2)
</script>
```
