# 面向对象和面向过程

## 概念理解

面向对象和面向过程，是两种不同的编程思想。  
理解这个知识点，是每一个开发者都会面临的话题，并且对初学者并不是很友好的话题。  
面向过程：

- 按步骤，一步一步的完成需求。

面向对象：

- 把需求中遇到的事物，分成一个一个的对象，每个对象只关注自己的问题即可。

- 完成需求时，需要用到那个对象，就找哪个对象。

比如，有一个需求是：把大象放冰箱里。  
**面向过程实现** ：

```
console.log('打开冰箱门')
```

console.log('把大象放到冰箱')

console.log('关上冰箱门')</code></pre>

**面向对象实现** ：

```
// 把需求中的大象 和 冰箱，抽离出来，封装为对象
let bingxiang = {
  name: '冰箱',
  width: 200,
  height: 200,
  pinpai: '海尔',
  kaimen: function () {
    console.log(this.name + '开门')
  },
  guanmen: function () {
    console.log(this.name + '关门')
  }
}
```

let daxiang = { weight: 5000, age: 3, walk: function () { console.log('会走路') }, eat: function () { console.log('吃东西') }}

// 最后，完成需求的时候，调用对象的方法来实现即可bingxiang.kaimen()daxiang.walk()bingxiang.guanmen()</code></pre>

**前端开发，用的更多的就是 面向过程** 。

## 面向对象三个特点

封装：

- 每个对象，都是独立的一个事物的表示，并且内部的某些值可以设置为私有，对外不可见，只提供有限的几个方法对外开放。

- 实际开发中，绝大多数都是使用别人封装好的东西，也就是开发者不需要了解对象内部是怎么实现的，你只需要按照说明或文档使用即可

多态：

- 多态，即多种状态。

- 在 JavaScript 语言中，多态体现的并不明显。

继承：

- 继承，通俗的说，就是龙生龙，凤生凤，老鼠的儿子会打洞。

- 对象的继承，可以简化代码，避免冗余代码的产生。

## 优缺点对比

**面向过程** ：

- **优点** ：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。

- **缺点** ：没有面向对象易维护、易复用、易扩展

**面向对象** ：

- **优点** ：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出高内聚低耦合的系统，使系统更加灵活、更加易于维护

- **缺点** ：性能比面向过程低 高内聚：对象的内部的逻辑，连接紧密。 低耦合：对象和对象之间的联系不大，不会造成 ”牵一发而动全身” 的问题。

# 再谈构造函数

了解或学习面向对象编程，构造函数是起点。一切都围绕构造函数来实现。  
通过构造函数创建对象的语法：

```
function Pig() {
  // this 表示实例对象，本例中表示obj
  this.name = '佩奇' // obj.name = '佩奇'
  this.age = 20
  this.say = function () {
    console.log(this.name + '我的佩奇')
  }
  this.eat = function () {
    console.log('吃饭')
  }
}
```

let obj = new Pig()

console.log(obj)</code></pre>

**构造函数中的 this 指向 实例对象** 。

# 构造函数的问题

示例代码：

```
function Pig(name, age) {
  // this 表示实例对象
  this.name = name // obj.name = '佩奇'
  this.age = age
  this.say = function () {
    console.log(this.name + '我的佩奇')
  }
  this.eat = function () {
    console.log('吃饭')
  }
}
```

let obj1 = new Pig('佩奇', 2)let obj2 = new Pig('乔治', 3)let obj3 = new Pig('老段', 4)console.log(obj1)console.log(obj2)console.log(obj3)</code></pre>

问题所在：  
![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660029567305-3c94dfe0-d3a5-452f-8d69-58bbabe14d6b.png#averageHue=%23f9f8f8&clientId=u8d4b4a46-00ac-4&from=paste&height=465&id=ue4313973&originHeight=581&originWidth=737&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65396&status=done&style=none&taskId=u6807871e-4bbc-46d4-b0eb-2b33c17b414&title=&width=589.6)  
如何解决？见下面的原型对象。

# 原型对象

- 任何函数都有原型对象，当然构造函数也不例外，内置构造函数也不例外

- 原型对象由系统分配

- 通过 【构造函数.prototype】这样的语法，即可找到构造函数的原型对象

- 将构造函数中的方法定义到原型对象上，即可解决浪费内存的问题

- 构造函数 和 原型对象中的 this 都指向 实例对象

示例代码：

```
function Pig(name, age) {
  // this 表示实例对象
  this.name = name // obj.name = '佩奇'
  this.age = age
}
```

// 任何一个函数(普通函数、构造函数、内置的Array、String)，都有原型对象// 原型对象由系统分配，不用程序员手动加// console.dir() 也是输出内容，而且输出后，可以展开，看到内部的结果// console.dir(Pig) // Pig.prototype 就是Pig的原型对象// 把构造函数中的 eat、say方法，加给原型对象Pig.prototype.say = function () { console.log('会说话')}

Pig.prototype.eat = function () { console.log('会吃饭')}

let obj1 = new Pig('佩奇', 2)let obj2 = new Pig('乔治', 3)let obj3 = new Pig('老段', 4)console.log(obj1)console.log(obj2)console.log(obj3)</code></pre>

图示：  
![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660031058940-68f2cc1d-40a5-4e26-90e1-d082754b53c9.png#averageHue=%23f9f8f8&clientId=u8d4b4a46-00ac-4&from=paste&height=462&id=u7eaf6f88&originHeight=578&originWidth=816&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35407&status=done&style=none&taskId=uc3d8f946-08fb-4aba-9c27-13078937024&title=&width=652.8)  
**结论** ：**所有对象的属性，放到构造函数中，所有的方法都加给原型对象** 。

# 案例 - 扩展数组方法

比如项目中，经常需要计算数组元素的和，为了方便起见，希望通过 [2, 4, 6].sum()这样的语法来完成计算。  
实现该方法的扩展，需要掌握：

- 数组也是对象

- **[2, 4, 6]** **等同于** **new Array(2, 4, 6)**

- new Array(2, 4, 6) 写起来麻烦，所以实际写代码的时候，几乎不会写

- [2, 4, 6] 这种写法，是字面量写法，写起来简单

图解：  
![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660033282996-cc1af372-f671-481f-84d1-291eb77613a4.png#averageHue=%23f9f7f6&clientId=u8d4b4a46-00ac-4&from=paste&height=378&id=ud4f996f4&originHeight=472&originWidth=829&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42052&status=done&style=none&taskId=udc8e4d4c-a812-4443-9874-1eef24ce913&title=&width=663.2)  
代码：

```js
// ------------------- 自己给 Array.prototype 添加一个方法 --------------
// 添加一个sum方法，作用是计算数组元素的和
Array.prototype.sum = function () {
  // this 表示实例对象，本例中 this 表示 [2, 3, 5, 8]
  return this.reduce((t, c) => t + c)
}
```

console.log([2, 3, 5, 8].sum()) // 18console.log([3, 9, 0, 2].sum())console.log([100, 200, 300].sum())</code></pre>

# 三角关系

面向对象中，经常提及 **构造函数** 、**原型对象** 、**实例对象** 。那么三者之间有什么关系呢？  
内置的Array来说明，图示如下：  
![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660034740643-fb9a9996-38d1-4741-ad57-6ac532c662b1.png#averageHue=%23faf9f8&clientId=u8d4b4a46-00ac-4&from=paste&height=315&id=u650957e3&originHeight=394&originWidth=821&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43252&status=done&style=none&taskId=u03d15fad-f7fe-482f-b0a2-a186e5c3295&title=&width=656.8)  
拿自定义的Pig函数来说，图示如下：  
![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660034961413-74bf41d0-7233-4312-b650-06d966c04bd8.png#averageHue=%23faf9f9&clientId=u8d4b4a46-00ac-4&from=paste&height=323&id=u03da8f72&originHeight=404&originWidth=783&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42003&status=done&style=none&taskId=uefb6ceab-ff18-48b3-b069-cf80e08d1a2&title=&width=626.4)

其实，实例对象的 [[Prototype]] 属性才指向 原型对象  
只不过，[[Prototype]] 是隐藏属性，不可访问，所以浏览器才实现了 __proto__ ，用于访问原型对象  
但是， __proto__ 是JS非标准属性，并且可能会被遗弃。  
建议使用 Object.getPrototypeOf(实例对象) 语法，来找原型对象。  
课堂代码：

```
// 声明构造函数
function Pig(name, age) {
  this.name = name
  this.age = age
}
```

// 向原型对象上加方法Pig.prototype.say = function () { }Pig.prototype.eat = function () { }

console.log(Pig.prototype.constructor) // Pig是构造函数；Pig.prototype找到原型对象；再点constructor再次找到构造函数

// 实例化let obj = new Pig('佩奇', 3)

console.log(obj.**proto**) // 通过实例对象，找到原型对象（非标准的，不建议用）console.log(Object.getPrototypeOf(obj)) // 通过该语法，找到原型对象（标准语法）

console.log(obj)</code></pre>

# 原型继承

通过**修改构造函数的原型对象** ，可以实现对象的继承。  
![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660037120309-12263782-1d52-46df-9f07-8d7c7a2b12f1.png#averageHue=%23fbfafa&clientId=u8d4b4a46-00ac-4&from=paste&height=509&id=u874a1aa4&originHeight=636&originWidth=1239&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112566&status=done&style=none&taskId=u0ff87942-1e5a-4209-b45e-c2bc818a4fc&title=&width=991.2)

通过原型继承后，需要手动修改原型对象的 constructor 属性。否则就不符合上述的三角关系了。 只要修改了原型对象，就得手动 指定 constructor 属性。 **固定语法** 构造函数.prototype.constructor = 构造函数

示例代码：

```
// -------------------------- Animal ---------------------------
function Animal() {
```

}Animal.prototype.eat = function () { console.log('会吃饭')}let a = new Animal()

// -------------------------- Pig ------------------------------function Pig() {

}Pig.prototype = a // 【关键】修改Pig的原型对象 为 a// 【关键】只要修改了原型对象，必须重置 constructor才行（否则三角关系就乱了）Pig.prototype.constructor = Piglet p = new Pig()

// 因为修改了Pig的原型对象 === Animal的实例对象，所以实例对象 p 就继承了a的方法、属性等等p.eat() // p对象，可以直接使用原型对象的原型对象上的方法，体现了继承

console.log(Pig.prototype.constructor)</code></pre>

# 原型链

原型链研究的是 对象属性的 查找机制。  
理解起来，并不是太难。

- 实例对象 有原型对象

- 原型对象也是对象，那也有原型对象..............

- 这样就形成了多层继承了

![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660038983232-4a55e293-5023-4da0-90f1-3ebf425262c8.png#averageHue=%23fcfbfb&clientId=u8d4b4a46-00ac-4&from=paste&height=537&id=u56dae5a3&originHeight=671&originWidth=1106&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55796&status=done&style=none&taskId=uc094666d-f878-4fe3-aa36-c3569208446&title=&width=884.8)  
**概念** ：  
基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为**原型链 (** 面试爱问**)**  
**对象属性(或方法)查找机制** ：

- 当查找对象的某个属性（包括方法）时，优先从当前对象自身中查找。

- 当做对象中没有该属性，则向上层原型对象中查找

- 如果原型对象中也没有该属性则继续向上层原型对象中查找

- .....................

- 一直找到最顶层为止。找到则使用该属性值，找不到则得到 undefined Object.prototype 是最顶层的原型对象。 Array、String等的原型对象的原型对象也是它

# instanceof 运算符

语法：

```
实例对象 instanceof 构造函数
```

比如：// 检测 p 的原型链上，是否有这个构造函数console.log(p instanceof Pig) // p的原型链上，有Pig这个构造函数，则返回trueconsole.log(p instanceof Animal) // p的原型链上，有Animal这个构造函数，则返回trueconsole.log(p instanceof Object) // p的原型链上，有Object这个构造函数，则返回true

console.log(p instanceof String) // p的原型链上，没有String这个构造函数，则返回false</code></pre>

作用：  
instanceof 运算符用于检测 实例对象的原型链上，是否有语法中给出的构造函数。

# 综合案例