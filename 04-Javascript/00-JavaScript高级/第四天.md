# 面向对象案例

## 实现基本的代码结构

```js
// 使用面向对象，必须有一个构造函
function Modal() {
  // 1. 通过JS的方式，动态创建 div
  this.div = 'hello'
}
// 2. 写一个显示弹出框的方法 show
Modal.prototype.show = function () {
  // 方法中，可以使用 this.div
  console.log(this.div)
}
// 3. 写一个关闭的方法 close
Modal.prototype.close = function () {
  // 方法中，可以使用 this.div
}

document.querySelector('#login').addEventListener('click', function () {
  let obj = new Modal() // 这一步介绍，obj就有div这个属性了
  obj.show() // 这一步，调用show方法，show方法中可以使用div属性的
})
```

## 设置构造函数的参数

```js
// 使用面向对象，必须有一个构造函
+function Modal(title, content) {
+  this.title = title
+  this.content = content
   // 1. 通过JS的方式，动态创建 div
   this.div = 'hello'
 }

document.querySelector('#login').addEventListener('click', function () {
+ let obj = new Modal('登录提示', '您还没有账号，请先注册') // 这一步介绍，obj就有div这个属性了
  obj.show() // 这一步，调用show方法，show方法中可以使用div属性的
})
```

## 构造函数内创建div

```js
// 使用面向对象，必须有一个构造函
function Modal(title, content) {
  this.title = title
  this.content = content
  // 1. 通过JS的方式，动态创建 div
  let a = document.createElement('div') // 创建一个 <div></div>
  // 给div加类
  a.classList.add('modal')  // <div class="modal"></div>
  // 给div添加内容
  a.innerHTML = `
    <div class="header">${title} <i>x</i></div>
    <div class="body">${this.content}</div>
  `
  // 把创建好的变量（也是div），赋值给实例对象的属性；只有这样，才能在后续的方法中调用它，或者说找到它
  this.div = a
}
```

## 显示和关闭方法

```js
// 2. 写一个显示弹出框的方法 show
Modal.prototype.show = function () {
  // 在页面中，找 div，如果找到则得到DOM对象；如果没有找到则得到null
  // DOM对象 --> true
  // null --> false  （转成布尔是false有 NaN 0 '' undefined null）
  // 下面的判断，如果页面中有这个div，则return
  if (document.querySelector('.modal')) return
  // 方法中，可以使用 this.div
  // console.log(this.div)
  // 父元素.appendChild(子元素)
  document.body.appendChild(this.div)
  // 创建完div，把div放到页面中之后，页面中就有这个div了。有这个div了，就能找到里面的 i 标签了
  // document是文档的意思，document.querySelector 表示在整个文档中查找元素
  // this.div 表示当前的弹出框，this.div.querySelector 表示在当前div中查找元素
  this.div.querySelector('i').addEventListener('click', () => {
    // 调用close方法
    this.close() // 由于事件处理函数，使用了箭头函数；所以这里的this指向外层show函数中的this，也表示实例对象了
  })
}
// 3. 写一个关闭的方法 close
Modal.prototype.close = function () {
  // 方法中，可以使用 this.div
  // 父元素.removeChild(子元素)
  document.body.removeChild(this.div)
}
```

多次点击登录，会创建很多个框。加一个判断，判断页面中有没有这个div。

# 对象的拷贝

## 直接赋值

赋值，就是一个 = ，比如 `let obj2 = obj1` 这就是赋值。![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660101207813-a3304ba6-62ca-4e2e-9321-b5ee93a8bfdc.png#averageHue=%23f9f8f8&clientId=u0c534017-63cf-4&from=paste&height=287&id=ucaf2bba3&originHeight=359&originWidth=672&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16736&status=done&style=none&taskId=u0eeefb57-5d6b-4291-9a3d-aa7885ee2ac&title=&width=537.6)  
总结：

- 原始类型（字符串、数字....）的值，直接赋值之后。只是把存储的值赋值给变量。赋值之后，两个变量互不影响。
- 引用类型（数组、对象）的值，因为存储的是地址，等号赋值之后，是把地址赋值给了另一个变量。修改其中一个对象的属性，另一个对象也跟着改了。      

## 浅拷贝

拷贝，就是把两个对象，完全的分开。  
目标：修改一个对象，另一个对象不受影响才行。  
**自己写循环，实现拷贝** ：

```js
let obj1 = {
  name: 'zs',
  age: 20,
  height: 180
}

let obj2 = {} // 写了这一行，已经表示 obj2 和 obj1 是两个不同的对象了
// obj2.name = 'zs'
// obj2.age = 20
// 循环遍历 obj1，循环一次，取obj1里面的一个属性，然后给obj2加上
for (let key in obj1) {
  // key 是 name、age、height
  // obj1[key] 是 zs、20、180
  // console.log(obj1[key]) // key是变量，必须用[]语法，而且绝对不能加引号
  obj2[key] = obj1[key]
}

// 尝试修改其中一个对象
obj1.age = 10000

console.log(obj1)
console.log(obj2)
```

问题：如果obj1里面有引用类型的值，代码如下：

```js
let obj1 = {
  name: 'zs',
  age: 20,
  height: 180,
+ info: {
+   sex: '男',
+   weight: 70
+ }
}
```

拷贝之后，图示如下：  
![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660103822611-6676e83e-5d01-40e1-bbc9-d03952c1a674.png#averageHue=%23f7f6f6&clientId=u23622dbb-8c57-4&from=paste&height=237&id=u308ecc78&originHeight=296&originWidth=897&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28587&status=done&style=none&taskId=u4254c808-9f3a-47dc-bab1-4e2c2b3dde5&title=&width=717.6)  
**像这样，只关注对象的第1层，只拷贝对象第1层的属性和属性值，这样的拷贝，就叫做浅拷贝** 。  

## 递归函数

本质上，也是函数。  
在函数内部，调用函数自身，这样的调用，叫做递归。  
**注意事项** ：
1. 在函数中调用它自己，这就是递归  
2.  写递归函数的时候，**必须设置一个终止条件（出口），否则就会形成死循环**  
**基本示例** ：

```js
// 1. 在函数中调用它自己，这就是递归
// 2. 写递归函数的时候，必须设置一个终止条件（出口），否则就会形成死循环

let i = 1
function fn() {
  // 如果i>10，利用return终止函数执行的特点。（这里并不是要返回一个值）
  if (i > 10) return
  console.log(i)
  i++
  // 在当前函数中，继续调用它自己，这样就形成了递归
  **fn()**
}

fn()
```

**案例：计算一个数的阶乘** ：

```
5的阶乘 = 5 * 4 * 3 * 2 * 1
10的阶乘 = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
```

```js
// 计算一个数的阶乘 ------------------------------------------------------
// 5的阶乘 = 5 * 4 * 3 * 2 * 1
// 10的阶乘 = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
// 写递归第1步，找规律。
// 规律：n的阶乘 = n * (n-1)的阶乘
// 写递归的第2步，明确函数的功能
// 接下来，写一个函数，函数的功能是计算一个数的阶乘（当我需要计算一个数的阶乘的时候，就调用这个函数）
// 写递归的第3步：相信自己

function fn(n) {
  // 如果n是1，则直接返回1
  if (n === 1) return 1
  // return n的阶乘
  return n * fn(n - 1)
}

console.log(fn(5))
console.log(fn(10))
```

**案例：计算斐波那契数列** ：

```js
位置：1  2  3  4  5  6  7  8  9 ....................... 40
数字：1  1  2  3  5  8  13 21 34 ...................... ??
// 第1位和第2位的数字，始终是1，不变
// 从第3位数字开始，数字 = 前一个数字 + 前前一个数字
```

```js
// ---------------------------------------------------------------------------
// 位置：1  2  3  4  5  6  7  8  9 .......................40
// 数字：1  1  2  3  5  8  13 21 34 ...................... ??
// 第1位和第2位的数字，始终是1，不变
// 规律：从第3位数字开始，数字 = 前一个数字 + 前前一个数字
// 规律：n位置的数字 = (n-1)位置的数字 + (n-2)位置的数字
// 写一个函数，功能是： 计算某个位置的数字 ，所以当我需要计算某个位置的数字时，就调用函数

function fn(n) {
  if (n === 1 || n === 2) return 1
  // return n-1位置的数字 + n-2位置的数字
  return fn(n - 1) + fn(n - 2)
}

console.log(fn(7)) // 13
console.log(fn(9)) // 34
console.log(fn(40)) // 102334155
```

## 深拷贝

**概念** ：深拷贝，通过递归，逐层将对象的属性、属性值拷贝给另一个对象，使得两个对象能够完全分开。

```js
let obj1 = {
  name: 'zs',
  age: 20,
  info: ['男', 180, 70],
  dog: {
    name: '旺财',
    color: 'black',
    child: {
      name: '小旺财',
      color: '花'
    }
  }
}


// 前提：
// 1. 准备好 需要拷贝的对象、或者数组
// 2. 准备好 一个空对象、或者空数组

// 拷贝的时候：
// 1. 先判断拷贝的值是数组吗
// 2. 再判断拷贝的值是对象吗
// 3. 不是数组，也不是对象，肯定是一个普通值，则直接拷贝

let obj2 = {}

// 相信自己，写一个函数，可以实现浅拷贝 （当我需要浅拷贝的时候，就调用这个函数）
function fn(obj1, obj2) {
  for (let key in obj1) {
    // 循环的时候，先判断，参见上面的 1、 2
    if (Array.isArray(obj1[key])) {
      obj2[key] = []
      // 现在，又需要把 obj1.info 里面的值，拷贝给 obj2.info 这个空数组
      // 这又是一个浅拷贝，当我需要浅拷贝的时候，就调用 fn 即可
      fn(obj1[key], obj2[key])
    } else if (obj1[key] instanceof Object) {
      obj2[key] = {}
      fn(obj1[key], obj2[key])
    } else {
      // 如果进入else，说明对象的值是普通的值，则直接拷贝
      obj2[key] = obj1[key]
    }
  }
}

fn(obj1, obj2)

// 尝试修改一个值
obj1.dog.color = '绿色'

console.log(obj1)
console.log(obj2)
```

## 其他拷贝方案

上述使用 `for (let key in obj) {}`  这样的语法实现的浅拷贝、深拷贝等等，讲解的主要目的是为了说明浅拷贝和深拷贝的概念。另外也可以增强编程能力。实际工作中，肯定不会写递归实现深拷贝。  
下面介绍其他拷贝的方案：

- Object.assign() ---- 本意是实现对象的合并，但是可以用于实现对象的 **浅** 拷贝。

```js
let obj1 = {
  name: 'zs',
  age: 20,
  dog: {
    name: '旺财',
    color: 'black'
  }
}

let obj2 = Object.assign({}, obj1)

obj2.name = 'lisi' // 修改对象第1层的属性值，另一个对象不受影响
obj2.dog.name = '小黑' // 修改对象第2层的属性值，另一个对象也跟着改了，说明是浅拷贝

console.log(obj1)
console.log(obj2)
```

- JSON.parse 和 JSON.stringify （注意：JSON中不能出现函数、undefined、但是可以实现深拷贝）

```js
let obj1 = {
  name: 'zs',
  age: 20,
  dog: {
    name: '旺财',
    color: 'black'
  },
  say: function () {
    console.log(123)
  }
}

// 通过 JSON.stringify 将上述对象先转为 JSON 字符串
let str = JSON.stringify(obj1)
// console.log(str)
// 把 str 字符串，转成对象
let obj2 = JSON.parse(str)

obj1.name = 'lisi'
obj1.dog.name = '小黑'

console.log(obj1)
console.log(obj2)
```

- 使用 前端知名的库 lodash 实现深、浅拷贝

```
<script src="./lodash.min.js"></script>
<script>
  let obj1 = {
    name: 'zs',
    age: 20,
    dog: {
      name: '旺财',
      color: 'black'
    },
    say: function () {
      console.log(123)
    }
  }

  // 浅拷贝
  // let obj2 = _.clone(obj1)

  // 深拷贝
  let obj2 = _.cloneDeep(obj1)


  obj1.name = 'lisi'
  obj1.dog.name = '小黑'
  console.log(obj1)
  console.log(obj2)
</script>
```

# 异常处理(知道语法)

异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行。  

## throw抛出异常

- throw 用于抛出异常
- 遇到异常的时候，就可以使用 throw 抛出
- **throw 和 new Error('错误提示') 搭配使用** 。
  throw new Error ('参数不对')
```js
function sum(x, y) {
  if (x === undefined || y === undefined) {
    // 如果符合这个条件，说明调用函数的时候，没有传递参数
    // return console.log('参数不对') // 左右结构，右侧的代码先运算
    // throw '参数不对'
    // 实际使用，经常用throw 和 new Error() 配合
    // throw new Error('错误描述信息')
    throw new Error('参数不对')
  }
  return x + y
}


// console.log(sum(3, 5))
console.log(sum())
```

## try...catch...语句(有用)

意思：和 if...else ... 差不多。  
语法：

```js
try {
  把你的代码全写到这里
  如果没有异常发生，则正常执行
  如果有异常发生，则会把异常自动抛出
} catch (e) {
  e 就是 try里面抛出的错误对象
  e.message 是一个固定的属性，表示错误描述信息
}
//
try{
}catch(e){
	
}
```

课堂代码：

```js
<script src="./lodash.min.js"></script>
<script>
  // _.abc()
  try {
    console.log(111) // 代码从上到下执行，这一行正常执行
    _.abc()   // 这里，调用了一个不存在的方法，发生异常，抛出异常；try里面后续的代码就不再执行了
    console.log(222) // 这行不执行
  } catch (e) {
    console.log(e.message) // 只输出错误描述信息
  }

  console.log(333) // 这行不受影响，正常执行
</script>
```

## debugger调试

```
function fn() {
  console.log(11)
  debugger  // 这里加一个断点，用于调试
  console.log(22)
  console.log(33)
}
fn()
```

# this指向及修改this指向

## this 指向总结

`this` 是 JavaScript 最具“魅惑”的知识点，不同的应用场合 `this` 的取值可能会有意想不到的结果，在此我们对以往学习过的关于【 `this`  默认的取值】情况进行归纳和总结。

- 普通函数中的this，表示调用者
- **箭头函数中的this，需要按照作用域链去查找即可**

**也可以分开记忆，以下是非箭头函数的总结** ：

- **全局中的 this 表示 window**
- **普通函数中的 this 表示 window**
- **定时器中的 this 表示 window**
- **事件处理函数中的this 表示事件源**
- **构造函数、对象方法、原型对象方法中的this，表示实例对象**
- **静态方法中的this，表示构造函数**

```js
// 1. 全局中的this
console.log(this) // window

// 2. 普通函数中的this
function fn() {
  console.log(this) // window
}
fn()  // window.fn()，window调用了fn函数，所以fn中的this表示window

// 3. 定时器中的this
// setTimeout(function () {
//   console.log(this) // window
// }, 100)

// 4. 事件处理函数中的this
document.body.addEventListener('click', function () {
  console.log(this) // 事件源，此例中，表示body这个DOM对象
})

// 5. 构造函数中，以及对象方法中，包括原型对象的方法中，this都表示实例对象
function Dog() {
  this.age = 20
  this.say = function () {
    console.log(this)
  }
}

Dog.prototype.eat = function () {
  console.log(this)
}

let d = new Dog()
d.say()
d.eat()

// 6. 构造函数的静态方法中，this表示构造函数Pig
function Pig() {

}
// 给构造函数，直接添加的方法，叫做静态方法
Pig.eat = function () {
  console.log(this)
}
// 调用的时候，只能使用构造函数调用
Pig.eat()
```

课堂练习：

```js
var age = 10
let obj = {
  age: 20,
  say: () => {
    // 函数作用域，外层就是全局作用域 （不要把对象的大括号当做一个作用域）
    console.log(this.age) // 10
  },
  eat: function () {
    // .... 这里的 this 表示 obj
    let fn = () => {
      console.log(this.age) // 箭头函数中没有this，所以这里的this指向eat方法中的this，即obj
    }
    fn()
  },
  wash: () => {
    function abc() {
      console.log(this.age)
    }
    abc()
  }
}

// obj.say()
// obj.eat()
obj.wash()
```

## 修改函数中this的指向

下面这三个方法，只能通过函数调用：

- fn.call()
- Math.max.call()      

### call

1. `call` 方法能够在调用函数的同时指定 `this` 的值
2. 使用 `call` 方法调用函数时，第1个参数为 `this` 指定的值
3. `call` 方法的其余参数会依次自动传入函数做为函数的参数

```js
// --------------------- call ---------------------
// let obj = { age: 20 }

// function fn(x, y) {
//   console.log(this)
//   console.log(x + y)
// }
// // fn() // 正常调用函数，函数中的this表示 window
// // 语法：fn.call(新的this, 3, 4)
// fn.call(obj, 3, 4)
// 总结：
// 1. 函数.call() 表示调用函数，原函数fn得以调用了
// 2. 修改了原函数中的this，改成call方法的第1个参数了
// 3. 如果原函数有形参，可以通过call方法为原函数传递实参
```

### apply

1. `apply` 方法能够在调用函数的同时指定 `this` 的值
2. 使用 `apply` 方法调用函数时，第1个参数为 `this` 指定的值
3. `apply` 方法第2个参数为数组，数组的单元值依次自动传入函数做为函数的参数

```
// ----------------------- apply --------------------
// let obj = { age: 20 }

// function fn(x, y) {
//   console.log(this)
//   console.log(x + y)
// }

// // 语法：fn.apply(新的this, [3, 4])
// fn.apply(obj, [4, 8])
// 总结：
// 1. 函数.apply() 表示调用函数，原函数fn得以调用了
// 2. 修改了原函数中的this，改成 apply 方法的第1个参数了
// 3. 如果原函数有形参，可以通过 apply 方法为原函数传递实参，但是必须使用数组格式
```

### bind

1. `bind` 方法并**不会调用函数** ，而是创建一个指定了 `this` 值的新函数
2. `bind`的语法和 `call`一样

```
// ----------------------- bind --------------------
let obj = { age: 20 }

function fn(x, y) {
  console.log(this)
  console.log(x + y)
}

// 语法：fn.bind(新的this, 5, 9)
// let a = fn.bind(obj, 5, 9)
// a()
fn.bind(obj, 5, 9)()
// 总结：
// 1. 函数.bind() 表示创建了一个新的函数，并且不会调用任何函数
// 2. 修改了新函数中的this，改成 bind 方法的第1个参数了
// 3. 如果原函数有形参，可以通过 bind 方法为新函数传递实参
```

# 防抖和节流

## 防抖

防抖（debounce）指的是：频繁触发某个操作时，只执行最后一次。

- 触发事件后，延迟一段时间（比如1s）执行事件中的代码
- 如果在这 1s 中之内，再次触发了该事件，则重新计时 1s，1s后执行事件中的代码
- 如果 1s 中之内，没有再次触发事件，则 1s 后就执行事件中的代码

![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660751868044-914d9cfa-f9d9-477e-9e76-60e955628f31.png#averageHue=%23fbf8f6&clientId=ua6a49c73-4731-4&from=paste&height=357&id=uc7b46576&originHeight=661&originWidth=683&originalType=binary&ratio=1&rotation=0&showTitle=false&size=151848&status=done&style=none&taskId=u60b94d57-c980-4ab3-9430-174747c1185&title=&width=368.4000244140625)  
![](https://cdn.nlark.com/yuque/0/2022/gif/22014993/1660752002488-f0223120-6555-4466-92d6-2791fec9e773.gif#averageHue=%23627953&clientId=ua6a49c73-4731-4&from=paste&height=282&id=u25e4f191&originHeight=225&originWidth=400&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u76a886d1-73c6-47a9-aca2-b51bf013fc1&title=&width=502)  
防抖一般通过定时器来实现：

- 当事件触发后，清除定时器（如果有的话）
- 将要执行的代码放到定时器中

下面是输入框的防抖：用户在输入框输入，只输出最终的结果。

```
<input type="text" />
<script>
  let timer
  document.querySelector('input').addEventListener('input', function () {
    // 清除可能存在的定时器
    clearTimeout(timer)
    timer = setTimeout(() => {
      console.log(this.value)
    }, 1000)
  })
</script>
```

**实际开发中，建议使用 lodash 封装好的** `**_.debounce(需要防抖的函数, 延迟时间)**`

```
// ------------------------------- 使用 lodash 的方法方法 ---------------------------
// document.querySelector('input').addEventListener('input', 函数)
// document.querySelector('input').addEventListener('input', _.debounce(函数, 1000))
document.querySelector('input').addEventListener('input', _.debounce(function () {
    console.log(this.value)
}, 1000))
```

## 淘宝搜索建议案例

```
// 加入 lodash 提供的 _.debounce(函数, 1000)

// 在输入框中输入商品，输入商品后，下面div中显示搜索建议。
// 找到输入框，注册 input 事件
document.querySelector('input').addEventListener('input', _.debounce(async function () {
  // 1. 获取输入框的值
  let val = this.value
  // 2. 判断，值是否为空
  if (val === '') {
    return (document.querySelector('#suggest-list').innerHTML = '')
  }
  // 3. 输入框中有值，则发送请求，获取搜索建议
  const { data: res } = await axios.get('http://www.itcbc.com:3006/api/suggest', {
    params: { q: val }
  })
  // console.log(res)
  let arr = res.result.map(item => {
    return `<div class="suggest-item">${item[0]}</div>`
  })
  document.querySelector('#suggest-list').innerHTML = arr.join('')
}, 1000))
```

## 节流

节流（throttle）指的是：单位时间内，频繁触发同一个操作，只会触发 1 次。

- 频繁触发某个事件的时候，比如触发 mousemove 、scroll 等 事件的时候
- 可能 1s 中只内，鼠标移动事件就会触发 10次，事件中代码就会执行10次，太频繁了
- 我们通过 JS代码控制，1s中之内，事件中的代码最多只能执行1次，这种减低频率的行为就是节流。

![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660752294442-3cea30f7-9553-4e71-82ab-3675f1ec7464.png#averageHue=%23fbf6f4&clientId=ua6a49c73-4731-4&from=paste&height=350&id=u89e7ad24&originHeight=600&originWidth=758&originalType=binary&ratio=1&rotation=0&showTitle=false&size=120582&status=done&style=none&taskId=u6ee3a67f-8720-41fb-8a52-1f97a4d30dc&title=&width=442.3999938964844)  
节流一般通过计算时间差来实现：

- 事件触发之前，定义当前 时间 start
- 事件触发后，获取 当前事件 now，然后用 now - start ，如果大于约定时间，则允许执行事件中的代码
- 事件中代码执行完，重置 start

```
<div style="background-color: pink; width: 300px; height: 300px"></div>
<script>
  let prev = Date.now() // 时间戳，单位毫秒
  document.querySelector('div').addEventListener('mousemove', function () {
    // console.log('事件触发了')
    let now = Date.now() // 事件触发时的诗句
    if (now - prev >= 1000) {
      console.log('这是一万行代码')
      prev = Date.now()
    }
  })
</script>
```

**实际开发中，建议使用 lodash 封装的** `**_.throttle(需要节流的函数, 间隔时间)**`

```js
// ---------------------- 使用lodash提供的函数节流 ---------------------------
// document.querySelector('div').addEventListener('mousemove', 函数)
// document.querySelector('div').addEventListener('mousemove', _.throttle(函数, 1000))
document.querySelector('div').addEventListener('mousemove', _.throttle(function () {
    console.log('一万行代码')
}, 1000))
```

## 视频播放位置案例

```js
let video = document.querySelector('video')

// 当视频播放的时候，播放的时间只要发生改变，就会触发下面的事件
video.addEventListener('timeupdate', _.throttle(function () {
  // console.log('视频播放到了', video.currentTime)
  // 将视频的播放时间，记录到本地存储
  localStorage.setItem('time', video.currentTime)
}, 1000))

// 引入的视频资源，如果可以播放了（开头加载好了），就会触发这个事件 ：loadeddata
video.addEventListener('loadeddata', function () {
  // video.currentTime = 本地存储中 存储的时间
  video.currentTime = localStorage.getItem('time')
})
```

## 小结

节流和防抖的区别是？

- 节流：频繁触发事件时，降低事件内代码的执行频率。 --- 降频
- 防抖：连续触发事件时，每触发一次事件就重新计时。 --- 重新计时，延迟执行

节流和防抖的使用场景是？

- 节流：会频繁触发的事件，比如鼠标移动，页面尺寸发生变化，滚动条滚动等，适合使用节流降频。
- 防抖：只需在最后一次触发事件时，就可以完成最终效果的情况下，比如搜索框输入，适合使用防抖。