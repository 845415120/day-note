# node相关

## 会安装node

- 去官网下载node，然后安装
- 不是越新的版本越好，到公司问一下同事，他们用的哪个版本，你就装哪个版本

- [https://nodejs.org/zh-cn/download/releases/](https://nodejs.org/zh-cn/download/releases/) 这里可以下载所有版本的 node
- windows系统，下载后缀 `.msi` 的
- Mac系统，下载后缀是 `.pkg` 的

- node安装到哪里，绝对不能更改它的位置

- 比如node安装到了 `D:/abc/hello/nodejs` 里了
- 路径中的任何文件夹，都不能重命名，也不能剪切到其他位置

- 安装node之后，npm工具也已经安装好了。

## 能够使用node运行js代码

在 xxx.js 中，写好JS代码，然后：

```
node xxx.js
```

## Node运行js代码能够干什么

能够把自己的电脑当做服务器。也就是启动一个本地服务。

然后浏览器就可以通过 localhost:端口 的方式访问页面(或接口)

# 包管理器

## 命令对比

|   |   |   |   |
|---|---|---|---|
||**npm**|**yarn**|**pnpm**|
|**初始化**|npm init / npm init -y|yarn init / yarn init -y|pnpm init|
|**安装项目包**|npm i 包名|yarn add 包名|pnpm add 包名|
|npm i 包名@版本号|yarn add 包名@版本号|pnpm add 包名@版本号|
|npm i 包名 -D|yarn add 包名 -D|pnpm add 包名 -D|
|npm i|yarn install 或 yarn|pnpm install 或 pnpm i|
|**移除项目包**|npm un 包名|yarn remove 包名|pnpm remove 包名|
|**全局包**|npm i 包名 -g  <br>npm i 包名 -g|yarn global add 包名  <br>yarn global remove 包名|pnpm global add 包名  <br>pnpm global remove 包名|

# 模块化语法

## CommonJS

- 导出： `module.exports = 导出的内容`
- 导入： `require('模块')`

## ES Module

- 默认导入导出（一个文件，最多只能有1个默认导出）

- 导出： export default 导出的内容
- 导入： import 变量 from '模块'

- 按需导入导出

- 导出：在需要被导出的变量前，加 export 关键字即可
- 导入：import { 变量, 变量, .... } from '模块' （变量必须和导出的变量同名）

- 一次性导入所有（包括默认导出的和按需导出的）

- import * as 变量 from '模块'

- 导入资源文件

- import '资源文件'
- import './abc.css'

# Webpack

- **理解** webpack是干什么的？

- 打包所有，打包一切
- 在webpack的世界中，一切皆模块（js、css、图片等等都是模块）
- webpack就是把我们src中哪些文件，整理融合到一起，这个过程就是打包

- **loader** 是干什么的？

- webpack默认只能打包 js 文件
- 如果项目中，import css文件、less文件、png文件等等，webpack是不能打包这些资源的
- 此时，需要loader来帮助webpack处理 less、css等等 非js 文件

- **项目开发时，使用什么命令**？

- npm run serve | yarn serve | pnpm run serve
- 使用这个命令，表示我们使用 自动打包插件
- 好处是打包速度快；检测文件的变化，文件改动后(保存后)，插件会自动帮我们打包
- 运行这个命令，相当于在本地开了一个服务，**我们必须使用 localhost:8080的方式访问项目**

- **项目打包时使用什么命令**？

- npm run build | yarn build | pnpm run build
- 将项目完成后，打包一次就可以了。会把项目的结果输出到 dist 文件夹。

不需要大家完整的配置webpack，后面的vue课中，会自动生成这些配置。

# 同源策略和跨域请求

## 同源

同源，说的是两个url之间的对比。如果两个url以下三个方面都相同，则这两个url同源，否则非同源。

- 协议（http、https、file、......）
- 主机地址（[www.itcbc.com）](http://www.itcbc.com%EF%BC%89)
- 端口号（:3006）

http协议默认的端口是 80；  https协议默认的端口是 443

![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1651215750454-b75a2cf9-3dfd-43f3-920c-2efaa82973e1.png#averageHue=%23decaca&clientId=ufc0259ae-f66e-4&from=paste&height=399&id=u6a22e54c&originHeight=499&originWidth=1459&originalType=binary&ratio=1&rotation=0&showTitle=false&size=77616&status=done&style=none&taskId=u043cbeab-6752-4ba7-9700-6a9e0721fc8&title=&width=1167.2)

## 同源策略

同源策略（同源政策）是**浏览器** 的一种保护机制。如果发送了一个请求，服务器返回结果后，浏览器会判断（检查）**打开页面的url**  和 **请求的接口地址** 是否同源。

- 如果同源则接收响应结果
- 如果不同源，则拒绝接收结果（造成请求失败）

# 跨域

凡是违反了同源策略的请求，都是跨域请求。  
我们这几天，请求的接口，都是跨域请求。正常来讲，都会请求失败。

目前，能够请求成功，是因为做了处理（见下文）

# 突破跨域的限制

**正常情况下（不做任何处理的情况下）** ，跨域请求，都不能实现。工作中，几乎都是跨域请求。  
那怎么办？  
所以，我们肯定要突破跨域请求的限制才行，否则就无法正常工作了。  
**突破跨域的限制，可以使用JSONP方案 或 CORS方案** 。

## CORS方案（用的多）

- 用的多
- 是标准的解决跨域的方案
- 兼容性不好（IE10+）
- 支持所有的请求方式
- 用起来方便的不要不要的

我们课程中使用的全部接口都是使用CORS方案实现的

使用CORS方案解决跨域

- 只需要后端程序员在做出响应的时候，加一个响应头（`Access-Control-Allow-Origin: *`）即可。
- 前端程序员不需要做任何处理，正常发送Ajax请求即可。

## JSONP方案（用的少）

- 用的少
- 不是标准的解决跨域的方案
- 是一个很古老的方案
- **JSONP请求，和Ajax无关，只支持GET请求，能够向服务器传递的参数比较小（只能拼到url上）** 。
- 了解一下实现原理即可

实现原理：

- 准备好一个函数，名字随意（比如叫做abcd），用于接收响应结果
- 使用script标签的src属性请求接口地址，并通过callback把函数名传给服务器即可

```
<script>
  // 提前准备好 abc 函数
  function abcd(res) {
    console.log(res)
  }
  
  // abcd({ "id": 100, "name": "hahaha", "age": 20 });
  // 你的函数名是abcd，参数是响应给你的数据哦~~~
</script>
<script src="http://www.itcbc.com:3006/api/jsonp?callback=abcd"></script>
```

![](https://cdn.nlark.com/yuque/0/2022/png/22014993/1660633686405-df37a1e5-7c2f-4ede-b25f-4626d5235a0f.png#averageHue=%23739d5a&clientId=ue42ed5dc-cbeb-4&from=paste&height=382&id=u928d484b&originHeight=478&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&size=120876&status=done&style=none&taskId=u9a65a5d7-33a0-4acf-856b-dcecef3077a&title=&width=1169.6)

---

End