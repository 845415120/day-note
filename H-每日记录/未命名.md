  
Search

[

Write



](https://medium.com/new-story?source=---two_column_layout_nav----------------------------------)

[

](https://medium.com/me/notifications?source=---two_column_layout_nav----------------------------------)

![pl22 jiang](https://miro.medium.com/v2/resize:fill:64:64/0*23g9p4AOq7iCszJS)

Get unlimited access to the best of Medium for less than $1/week.

[

Become a member

](https://medium.com/plans?source=upgrade_membership---post_top_nav_upsell----------------------------------)

# Ultimate Python Cheat Sheet: Practical Python For Everyday Tasks  
终极 Python 备忘单：用于日常任务的实用 Python

[

![Neelam Yadav](https://miro.medium.com/v2/resize:fill:88:88/1*dP6Rk94ZiKwLz8KynBdReA.png)









](https://medium.com/@yaduvanshineelam09?source=post_page-----8a33abc0892f--------------------------------)

[Neelam Yadav](https://medium.com/@yaduvanshineelam09?source=post_page-----8a33abc0892f--------------------------------)

·

Follow

33 min read

·

5 days ago

415

[

](https://medium.com/plans?dimension=post_audio_button&postId=8a33abc0892f&source=upgrade_membership---post_audio_button----------------------------------)

![](https://miro.medium.com/v2/resize:fit:318/1*3rBsT1Ios33Fwlg2gFGbuw.jpeg)

This Cheat Sheet is a product of necessity. Tasked with re-engaging with a Python project after an extended stint in Node/Typescript territory, I realized the urgency of refreshing my grasp on Python’s latest features, adhering to best practices, and utilizing impactful tools.  
此备忘单是必需品。在 Node/Typescript 领域工作了很长时间后，我的任务是重新参与 Python 项目，我意识到更新我对 Python 最新功能的掌握、坚持最佳实践和利用有影响力的工具的紧迫性。

Python’s practical syntax and structure have always appealed to me. However, transitioning back from another language ecosystem demanded a swift reacquaintance with Python’s essentials, avoiding unnecessary intricacies. Thus, I compiled this guide to serve as a quick reference for the tasks, features, and tools crucial for immediate application.  
Python 的实用语法和结构一直吸引着我。然而，从另一个语言生态系统过渡回来需要迅速重新熟悉 Python 的本质，避免不必要的复杂性。因此，我编写了本指南，作为对立即应用至关重要的任务、功能和工具的快速参考。

This compilation represents the culmination of my journey, distilling practical Python insights, knowledge, and invaluable libraries into a concise resource. It aims to share the most significant learning experiences I encountered, presented in a format readily applicable to your projects and challenges.  
这个汇编代表了我旅程的高潮，将实用的 Python 见解、知识和宝贵的库提炼成一个简洁的资源。它旨在分享我遇到的最重要的学习经验，以适用于您的项目和挑战的格式呈现。

The guide is structured into logical sections corresponding to common tasks and domains, allowing swift navigation to relevant information. Topics range from file operations to API interactions, spreadsheet manipulation, mathematical computations, and data structure manipulation. Additionally, I’ll highlight key libraries to enrich your Python toolkit, enhancing your capabilities in Python’s typical domains.  
该指南分为与常见任务和领域相对应的逻辑部分，可以快速导航到相关信息。主题范围从文件操作到 API 交互、电子表格操作、数学计算和数据结构操作。此外，我将重点介绍一些关键库，以丰富您的 Python 工具包，增强您在 Python 典型领域的能力。

If you think I missed anything that should be included in the Cheat Sheet, please let me know in the comments and I’ll update the list!  
如果您认为我遗漏了备忘单中应包含的任何内容，请在评论中告诉我，我会更新列表！

# Working With Files 使用文件

# 1. Reading a File 1. 读取文件

To read the entire content of a file:  
要读取文件的全部内容：

with open('example.txt', 'r') as file:  
    content = file.read()  
    print(content)

# 2. Writing to a File  
2. 写入文件

To write text to a file, overwriting existing content:  
要将文本写入文件，覆盖现有内容，请执行以下操作：

with open('example.txt', 'w') as file:  
    file.write('Hello, Python!')

# 3. Appending to a File  
3. 追加到文件

To add text to the end of an existing file:  
要将文本添加到现有文件的末尾：

with open('example.txt', 'a') as file:  
    file.write('\nAppend this line.')

# 4. Reading Lines into a List  
4. 将行读入列表

To read a file line by line into a list:  
要将文件逐行读取到列表中：

with open('example.txt', 'r') as file:  
    lines = file.readlines()  
    print(lines)

# 5. Iterating Over Each Line in a File  
5. 遍历文件中的每一行

To process each line in a file:  
要处理文件中的每一行：

with open('example.txt', 'r') as file:  
    for line in file:  
        print(line.strip())

# 6. Checking If a File Exists  
6. 检查文件是否存在

To check if a file exists before performing file operations:  
要在执行文件操作之前检查文件是否存在，请执行以下操作：

import os  
if os.path.exists('example.txt'):  
    print('File exists.')  
else:  
    print('File does not exist.')

# 7. Writing Lists to a File  
7. 将列表写入文件

To write each element of a list to a new line in a file:  
要将列表的每个元素写入文件中的新行，请执行以下操作：

lines = ['First line', 'Second line', 'Third line']  
with open('example.txt', 'w') as file:  
    for line in lines:  
        file.write(f'{line}\n')

# 8. Using With Blocks for Multiple Files  
8. 与多个文件的块一起使用

To work with multiple files simultaneously using `with` blocks:  
要使用 `with` 块同时处理多个文件：

with open('source.txt', 'r') as source, open('destination.txt', 'w') as destination:  
    content = source.read()  
    destination.write(content)

# 9. Deleting a File 9. 删除文件

To safely delete a file if it exists:  
要安全删除文件（如果存在）：

import os  
if os.path.exists('example.txt'):  
    os.remove('example.txt')  
    print('File deleted.')  
else:  
    print('File does not exist.')

# 10. Reading and Writing Binary Files  
10. 读取和写入二进制文件

To read from and write to a file in binary mode (useful for images, videos, etc.):  
要以二进制模式读取和写入文件（对图像、视频等有用）：

# Reading a binary file  
with open('image.jpg', 'rb') as file:  
    content = file.read()  
# Writing to a binary file  
with open('copy.jpg', 'wb') as file:  
    file.write(content)

# Working With Simple HTTP APIs  
使用简单的 HTTP API

# 1. Basic GET Request 1. 基本 GET 请求

To fetch data from an API endpoint using a GET request:  
要使用 GET 请求从 API 终端节点获取数据，请执行以下操作：

import requests  
response = requests.get('https://api.example.com/data')  
data = response.json()  # Assuming the response is JSON  
print(data)

# 2. GET Request with Query Parameters  
2. 带有查询参数的 GET 请求

To send a GET request with query parameters:  
要发送带有查询参数的 GET 请求，请执行以下操作：

import requests  
params = {'key1': 'value1', 'key2': 'value2'}  
response = requests.get('https://api.example.com/search', params=params)  
data = response.json()  
print(data)

# 3. Handling HTTP Errors 3. 处理 HTTP 错误

To handle possible HTTP errors gracefully:  
要正常处理可能的 HTTP 错误，请执行以下操作：

import requests  
response = requests.get('https://api.example.com/data')  
try:  
    response.raise_for_status()  # Raises an HTTPError if the status is 4xx, 5xx  
    data = response.json()  
    print(data)  
except requests.exceptions.HTTPError as err:  
    print(f'HTTP Error: {err}')

# 4. Setting Timeout for Requests  
4. 设置请求超时

To set a timeout for API requests to avoid hanging indefinitely:  
要为 API 请求设置超时以避免无限期挂起，请执行以下操作：

import requests  
try:  
    response = requests.get('https://api.example.com/data', timeout=5)  # Timeout in seconds  
    data = response.json()  
    print(data)  
except requests.exceptions.Timeout:  
    print('The request timed out')

# 5. Using Headers in Requests  
5. 在请求中使用标头

To include headers in your request (e.g., for authorization):  
要在请求中包含标头（例如，用于授权）：

import requests  
headers = {'Authorization': 'Bearer YOUR_ACCESS_TOKEN'}  
response = requests.get('https://api.example.com/protected', headers=headers)  
data = response.json()  
print(data)

# 6. POST Request with JSON Payload  
6. 使用 JSON 有效负载的 POST 请求

To send data to an API endpoint using a POST request with a JSON payload:  
要使用带有 JSON 有效负载的 POST 请求将数据发送到 API 终端节点，请执行以下操作：

import requests  
payload = {'key1': 'value1', 'key2': 'value2'}  
headers = {'Content-Type': 'application/json'}  
response = requests.post('https://api.example.com/submit', json=payload, headers=headers)  
print(response.json())

# 7. Handling Response Encoding  
7. 处理响应编码

To handle the response encoding properly:  
要正确处理响应编码，请执行以下操作：

import requests  
response = requests.get('https://api.example.com/data')  
response.encoding = 'utf-8'  # Set encoding to match the expected response format  
data = response.text  
print(data)

# 8. Using Sessions with Requests  
8. 将会话与请求一起使用

To use a session object for making multiple requests to the same host, which can improve performance:  
要使用会话对象向同一主机发出多个请求，这可以提高性能，请执行以下操作：

import requests  
with requests.Session() as session:  
    session.headers.update({'Authorization': 'Bearer YOUR_ACCESS_TOKEN'})  
    response = session.get('https://api.example.com/data')  
    print(response.json())

# 9. Handling Redirects 9. 处理重定向

To handle or disable redirects in requests:  
要处理或禁用请求中的重定向，请执行以下操作：

import requests  
response = requests.get('https://api.example.com/data', allow_redirects=False)  
print(response.status_code)

# 10. Streaming Large Responses  
10. 流式传输大型响应

To stream a large response to process it in chunks, rather than loading it all into memory:  
要流式传输大型响应以分块处理它，而不是将其全部加载到内存中：

import requests  
response = requests.get('https://api.example.com/large-data', stream=True)  
for chunk in response.iter_content(chunk_size=1024):  
    process(chunk)  # Replace 'process' with your actual processing function

# Working With Lists 使用列表

# 1. Creating a List 1. 创建列表

To conjure a list into being:  
要使列表成为现实，请执行以下操作：

# A list of mystical elements  
elements = ['Earth', 'Air', 'Fire', 'Water']

# 2. Appending to a List  
2. 附加到列表

To append a new element to the end of a list:  
要将新元素追加到列表末尾，请执行以下操作：

elements.append('Aether')

# 3. Inserting into a List  
3. 插入到列表中

To insert an element at a specific position in the list:  
要在列表中的特定位置插入元素，请执行以下操作：

# Insert 'Spirit' at index 1  
elements.insert(1, 'Spirit')

# 4. Removing from a List  
4. 从列表中删除

To remove an element by value from the list:  
要从列表中按值删除元素：

elements.remove('Earth')  # Removes the first occurrence of 'Earth'

# 5. Popping an Element from a List  
5. 从列表中弹出元素

To remove and return an element at a given index (default is the last item):  
要删除并返回给定索引处的元素（默认值为最后一项）：

last_element = elements.pop()  # Removes and returns the last element

# 6. Finding the Index of an Element  
6. 查找元素的索引

To find the index of the first occurrence of an element:  
要查找元素首次出现的索引，请执行以下操作：

index_of_air = elements.index('Air')

# 7. List Slicing 7. 列表切片

To slice a list, obtaining a sub-list:  
要对列表进行切片，获取子列表：

# Get elements from index 1 to 3  
sub_elements = elements[1:4]

# 8. List Comprehension 8.列表理解

To create a new list by applying an expression to each element of an existing one:  
要通过将表达式应用于现有列表的每个元素来创建新列表，请执行以下操作：

# Create a new list with lengths of each element  
lengths = [len(element) for element in elements]

# 9. Sorting a List 9. 对列表进行排序

To sort a list in ascending order (in-place):  
要按升序对列表进行排序（就地）：

elements.sort()

# 10. Reversing a List 10. 反转列表

To reverse the elements of a list in-place:  
要就地反转列表的元素，请执行以下操作：

elements.reverse()

# Working With Dictionaries  
使用词典

# 1. Creating a Dictionary 1. 创建字典

To forge a new dictionary:  
要伪造新词典：

# A tome of elements and their symbols  
elements = {'Hydrogen': 'H', 'Helium': 'He', 'Lithium': 'Li'}

# 2. Adding or Updating Entries  
2. 添加或更新条目

To add a new entry or update an existing one:  
要添加新条目或更新现有条目：

elements['Carbon'] = 'C'  # Adds 'Carbon' or updates its value to 'C'

# 3. Removing an Entry 3. 删除条目

To banish an entry from the dictionary:  
要从字典中删除条目：

del elements['Lithium']  # Removes the key 'Lithium' and its value

# 4. Checking for Key Existence  
4. 检查密钥是否存在

To check if a key resides within the dictionary:  
要检查字典中是否存在某个键：

if 'Helium' in elements:  
    print('Helium is present')

# 5. Iterating Over Keys 5. 迭代键

To iterate over the keys in the dictionary:  
要遍历字典中的键，请执行以下操作：

for element in elements:  
    print(element)  # Prints each key

# 6. Iterating Over Values 6. 迭代值

To traverse through the values in the dictionary:  
要遍历字典中的值，请执行以下操作：

for symbol in elements.values():  
    print(symbol)  # Prints each value

# 7. Iterating Over Items 7. 迭代项目

To journey through both keys and values together:  
要同时了解密钥和价值观：

for element, symbol in elements.items():  
    print(f'{element}: {symbol}')

# 8. Dictionary Comprehension  
8. 字典理解

To conjure a new dictionary through an incantation over an iterable:  
要通过对可迭代的咒语来召唤新词典：

# Squares of numbers from 0 to 4  
squares = {x: x**2 for x in range(5)}

# 9. Merging Dictionaries 9. 合并词典

To merge two or more dictionaries, forming a new alliance of their entries:  
要合并两个或多个词典，形成其条目的新联盟：

alchemists = {'Paracelsus': 'Mercury'}  
philosophers = {'Plato': 'Aether'}  
merged = {**alchemists, **philosophers}  # Python 3.5+

# 10. Getting a Value with Default  
10. 获取默认值

To retrieve a value safely, providing a default for absent keys:  
要安全地检索值，为缺席的键提供默认值，请执行以下操作：

element = elements.get('Neon', 'Unknown')  # Returns 'Unknown' if 'Neon' is not found

# Working With The Operating System  
使用操作系统

# 1. Navigating File Paths 1. 导航文件路径

To craft and dissect paths, ensuring compatibility across realms (operating systems):  
要创建和剖析路径，确保跨领域（操作系统）的兼容性：

import os  
# Craft a path compatible with the underlying OS  
path = os.path.join('mystic', 'forest', 'artifact.txt')  
# Retrieve the tome's directory  
directory = os.path.dirname(path)  
# Unveil the artifact's name  
artifact_name = os.path.basename(path)

# 2. Listing Directory Contents  
2. 列出目录内容

To reveal all entities within a mystical directory:  
要揭示神秘目录中的所有实体：

import os  
contents = os.listdir('enchanted_grove')  
print(contents)

# 3. Creating Directories 3. 创建目录

To conjure new directories within the fabric of the filesystem:  
要在文件系统的结构中召唤新目录：

import os  
# create a single directory  
os.mkdir('alchemy_lab')  
# create a hierarchy of directories  
os.makedirs('alchemy_lab/potions/elixirs')

# 4. Removing Files and Directories  
4. 删除文件和目录

To erase files or directories, banishing their essence:  
要擦除文件或目录，消除其本质：

import os  
# remove a file  
os.remove('unnecessary_scroll.txt')  
# remove an empty directory  
os.rmdir('abandoned_hut')  
# remove a directory and its contents  
import shutil  
shutil.rmtree('cursed_cavern')

# 5. Executing Shell Commands  
5. 执行 shell 命令

To invoke the shell’s ancient powers directly from Python:  
要直接从 Python 调用 shell 的古老力量：

import subprocess  
# Invoke the 'echo' incantation  
result = subprocess.run(['echo', 'Revealing the arcane'], capture_output=True, text=True)  
print(result.stdout)

# 6. Working with Environment Variables  
6. 使用环境变量

To read and inscribe upon the ethereal environment variables:  
读取并刻在虚无缥缈的环境变量上：

import os  
# Read the 'PATH' variable  
path = os.environ.get('PATH')  
# Create a new environment variable  
os.environ['MAGIC'] = 'Arcane'

# 7. Changing the Current Working Directory  
7. 更改当前工作目录

To shift your presence to another directory within the filesystem:  
要将您的状态转移到文件系统中的另一个目录：

import os  
# Traverse to the 'arcane_library' directory  
os.chdir('arcane_library')

# 8. Path Existence and Type  
8. 路径存在和类型

To discern the existence of paths and their nature — be they file or directory:  
要辨别路径的存在及其性质 - 无论是文件还是目录：

import os  
# Check if a path exists  
exists = os.path.exists('mysterious_ruins')  
# Ascertain if the path is a directory  
is_directory = os.path.isdir('mysterious_ruins')  
# Determine if the path is a file  
is_file = os.path.isfile('ancient_manuscript.txt')

# 9. Working with Temporary Files  
9. 使用临时文件

To summon temporary files and directories, fleeting and ephemeral:  
要召唤临时文件和目录，转瞬即逝：

import tempfile  
# Create a temporary file  
temp_file = tempfile.NamedTemporaryFile(delete=False)  
print(temp_file.name)  
# Erect a temporary directory  
temp_dir = tempfile.TemporaryDirectory()  
print(temp_dir.name)

# 10. Getting System Information  
10. 获取系统信息

To unveil information about the host system, its name, and the enchantments it supports:  
要揭示有关主机系统、其名称及其支持的附魔的信息，请执行以下操作：

import os  
import platform  
# Discover the operating system  
os_name = os.name  # 'posix', 'nt', 'java'  
# Unearth detailed system information  
system_info = platform.system()  # 'Linux', 'Windows', 'Darwin'

# Working With CLI — STDIN, STDOUT, STDERR  
使用 CLI — STDIN、STDOUT、STDERR

# 1. Reading User Input 1. 读取用户输入

Getting input from STDIN:  
从 STDIN 获取输入：

user_input = input("Impart your wisdom: ")  
print(f"You shared: {user_input}")

# 2. Printing to STDOUT 2. 打印到 STDOUT

To print messages to the console:  
要将消息打印到控制台，请执行以下操作：

print("Behold, the message of the ancients!")

# 3. Formatted Printing 3. 格式化打印

To weave variables into your messages with grace and precision:  
要优雅而精确地将变量编织到您的消息中：

name = "Merlin"  
age = 300  
print(f"{name}, of {age} years, speaks of forgotten lore.")

# 4. Reading Lines from STDIN  
4. 从 STDIN 读取行

Trim whitespaces line by line from STDIN:  
从 STDIN 逐行修剪空格：

import sys  
for line in sys.stdin:  
    print(f"Echo from the void: {line.strip()}")

# 5. Writing to STDERR 5. 写信给 STDERR

To send message to STDERR:  
要向 STDERR 发送消息：

import sys  
sys.stderr.write("Beware! The path is fraught with peril.\n")

# 6. Redirecting STDOUT 6. 重定向 STDOUT

To redirect the STDOUT: 要重定向 STDOUT：

import sys  
original_stdout = sys.stdout  # Preserve the original STDOUT  
with open('mystic_log.txt', 'w') as f:  
    sys.stdout = f  # Redirect STDOUT to a file  
    print("This message is inscribed within the mystic_log.txt.")  
sys.stdout = original_stdout  # Restore STDOUT to its original glory

# 7. Redirecting STDERR 7. 重定向 STDERR

Redirecting STDERR: 重定向 STDERR：

import sys  
with open('warnings.txt', 'w') as f:  
    sys.stderr = f  # Redirect STDERR  
    print("This warning is sealed within warnings.txt.", file=sys.stderr)

# 8. Prompting for Passwords  
8. 提示输入密码

To prompt for passwords: 要提示输入密码：

import getpass  
secret_spell = getpass.getpass("Whisper the secret spell: ")

# 9. Command Line Arguments  
9. 命令行参数

Working with and parsing command line arguments:  
使用和解析命令行参数：

import sys  
# The script's name is the first argument, followed by those passed by the invoker  
script, first_arg, second_arg = sys.argv  
print(f"Invoked with the sacred tokens: {first_arg} and {second_arg}")

# 10. Using Argparse for Complex CLI Interactions  
10. 使用 Argparse 进行复杂的 CLI 交互

Adding descriptions and options/arguments:  
添加描述和选项/参数：

import argparse  
parser = argparse.ArgumentParser(description="Invoke the ancient scripts.")  
parser.add_argument('spell', help="The spell to cast")  
parser.add_argument('--power', type=int, help="The power level of the spell")  
args = parser.parse_args()  
print(f"Casting {args.spell} with power {args.power}")

# Working With Mathematical Operations and Permutations  
使用数学运算和排列

# 1. Basic Arithmetic Operations  
1. 基本算术运算

To perform basic arithmetic:  
要执行基本算术：

sum = 7 + 3  # Addition  
difference = 7 - 3  # Subtraction  
product = 7 * 3  # Multiplication  
quotient = 7 / 3  # Division  
remainder = 7 % 3  # Modulus (Remainder)  
power = 7 ** 3  # Exponentiation

# 2. Working with Complex Numbers  
2. 使用复数

To work with complex numbers:  
要使用复数：

z = complex(2, 3)  # Create a complex number 2 + 3j  
real_part = z.real  # Retrieve the real part  
imaginary_part = z.imag  # Retrieve the imaginary part  
conjugate = z.conjugate()  # Get the conjugate

# 3. Mathematical Functions  
3. 数学函数

Common math functions: 常用数学函数：

import math  
root = math.sqrt(16)  # Square root  
logarithm = math.log(100, 10)  # Logarithm base 10 of 100  
sine = math.sin(math.pi / 2)  # Sine of 90 degrees (in radians)

# 4. Generating Permutations  
4. 生成排列

Easy way to generate permutations from a given set:  
从给定集合生成排列的简单方法：

from itertools import permutations  
paths = permutations([1, 2, 3])  # Generate all permutations of the list [1, 2, 3]  
for path in paths:  
    print(path)

# 5. Generating Combinations  
5. 生成组合

Easy way to generate combinations:  
生成组合的简单方法：

from itertools import combinations  
combos = combinations([1, 2, 3, 4], 2)  # Generate all 2-element combinations  
for combo in combos:  
    print(combo)

# 6. Random Number Generation  
6. 随机数生成

To get a random number:  
要获取随机数：

import random  
num = random.randint(1, 100)  # Generate a random integer between 1 and 100

# 7. Working with Fractions  
7. 使用分数

When you need to work with fractions:  
当您需要处理分数时：

from fractions import Fraction  
f = Fraction(3, 4)  # Create a fraction 3/4  
print(f + 1)  # Add a fraction and an integer

# 8. Statistical Functions 8. 统计函数

To get Average, Median, and Standard Deviation:  
要获取平均值、中位数和标准差，请执行以下操作：

import statistics  
data = [1, 2, 3, 4, 5]  
mean = statistics.mean(data)  # Average  
median = statistics.median(data)  # Median  
stdev = statistics.stdev(data)  # Standard Deviation

# 9. Trigonometric Functions  
9. 三角函数

To work with trigonometry:  
要使用三角函数：

import math  
angle_rad = math.radians(60)  # Convert 60 degrees to radians  
cosine = math.cos(angle_rad)  # Cosine of the angle

# 10. Handling Infinity and NaN  
10. 处理无穷大和 NaN

To work with Infinity and NaN:  
要使用 Infinity 和 NaN，请执行以下操作：

import math  
infinity = math.inf  # Representing infinity  
not_a_number = math.nan  # Representing a non-number (NaN)

# Working With Databases 使用数据库

# 1. Establishing a Connection  
1. 建立连接

To create a connection to a Postgres Database:  
要创建与 Postgres 数据库的连接，请执行以下操作：

import psycopg2  
connection = psycopg2.connect(  
    dbname='your_database',  
    user='your_username',  
    password='your_password',  
    host='your_host'  
)

# 2. Creating a Cursor 2. 创建光标

To create a database cursor, enabling the traversal and manipulation of records:  
要创建数据库游标，启用记录的遍历和操作，请执行以下操作：

cursor = connection.cursor()

# 3. Executing a Query 3. 执行查询

Selecting data from Database:  
从数据库中选择数据：

cursor.execute("SELECT * FROM your_table")

# 4. Fetching Query Results  
4. 获取查询结果

Fetching data with a cursor:  
使用游标获取数据：

records = cursor.fetchall()  
for record in records:  
    print(record)

# 5. Inserting Records 5. 插入记录

To insert data into tables in a database:  
要将数据插入到数据库的表中：

cursor.execute("INSERT INTO your_table (column1, column2) VALUES (%s, %s)", ('value1', 'value2'))  
connection.commit()  # Seal the transaction

# 6. Updating Records 6. 更新记录

To alter the records: 要更改记录，请执行以下操作：

cursor.execute("UPDATE your_table SET column1 = %s WHERE column2 = %s", ('new_value', 'condition_value'))  
connection.commit()

# 7. Deleting Records 7. 删除记录

To delete records from the table:  
要从表中删除记录，请执行以下操作：

cursor.execute("DELETE FROM your_table WHERE condition_column = %s", ('condition_value',))  
connection.commit()

# 8. Creating a Table 8. 创建表

To create a new table, defining its structure:  
要创建新表，请定义其结构：

cursor.execute("""  
    CREATE TABLE your_new_table (  
        id SERIAL PRIMARY KEY,  
        column1 VARCHAR(255),  
        column2 INTEGER  
    )  
""")  
connection.commit()

# 9. Dropping a Table 9. 删除表格

To drop a table: 要删除表：

cursor.execute("DROP TABLE if exists your_table")  
connection.commit()

# 10. Using Transactions 10. 使用交易

To use transactions for atomicity:  
要将事务用于原子性，请执行以下操作：

try:  
    cursor.execute("your first transactional query")  
    cursor.execute("your second transactional query")  
    connection.commit()  # Commit if all is well  
except Exception as e:  
    connection.rollback()  # Rollback in case of any issue  
    print(f"An error occurred: {e}")

# Working With Async IO (Asyncrounous Programming)  
使用异步 IO（异步编程）

# 1. Defining an Asynchronous Function  
1. 定义异步函数

To declare an async function:  
要声明异步函数，请执行以下操作：

import asyncio  
async def fetch_data():  
    print("Fetching data...")  
    await asyncio.sleep(2)  # Simulate an I/O operation  
    print("Data retrieved.")

# 2. Running an Asynchronous Function  
2. 运行异步函数

To invoke an asynchronous function and await them:  
要调用异步函数并等待它们，请执行以下操作：

async def main():  
    await fetch_data()  
asyncio.run(main())

# 3. Awaiting Multiple Coroutines  
3. 等待多个协程

To invoke multiple async functions and await all:  
要调用多个异步函数并等待所有函数，请执行以下操作：

async def main():  
    task1 = fetch_data()  
    task2 = fetch_data()  
    await asyncio.gather(task1, task2)  
asyncio.run(main())

# 4. Creating Tasks 4. 创建任务

To dispatch tasks: 要分派任务：

async def main():  
    task1 = asyncio.create_task(fetch_data())  
    task2 = asyncio.create_task(fetch_data())  
    await task1  
    await task2  
asyncio.run(main())

# 5. Asynchronous Iteration  
5. 异步迭代

To traverse through asynchronously, allowing time for other functions in between:  
要异步遍历，为中间的其他函数留出时间：

async def fetch_item(item):  
    await asyncio.sleep(1)  # Simulate an I/O operation  
    print(f"Fetched {item}")  
async def main():  
    items = ['potion', 'scroll', 'wand']  
    for item in items:  
        await fetch_item(item)  
asyncio.run(main())

# 6. Using Asynchronous Context Managers  
6. 使用异步上下文管理器

To ensure resources are managed within the bounds of an asynchronous function:  
要确保资源在异步函数的范围内进行管理，请执行以下操作：

async def async_context_manager():  
    print("Entering context")  
    await asyncio.sleep(1)  
    print("Exiting context")  
async def main():  
    async with async_context_manager():  
        print("Within context")  
asyncio.run(main())

# 7. Handling Exceptions in Asynchronous Code  
7. 处理异步代码中的异常

To gracefully catch and manage the errors with async functions:  
若要使用异步函数正常捕获和管理错误，请执行以下操作：

async def risky_spell():  
    await asyncio.sleep(1)  
    raise ValueError("The spell backfired!")  
async def main():  
    try:  
        await risky_spell()  
    except ValueError as e:  
        print(f"Caught an error: {e}")  
asyncio.run(main())

# 8. Asynchronous Generators  
8. 异步发电机

To create async generators, each arriving in its own time:  
要创建异步生成器，每个生成器在自己的时间到达：

async def fetch_items():  
    items = ['crystal', 'amulet', 'dagger']  
    for item in items:  
        await asyncio.sleep(1)  
        yield item  
async def main():  
    async for item in fetch_items():  
        print(f"Found {item}")  
asyncio.run(main())

# 9. Using Semaphores 9. 使用信号量

To limit the number of concurrent tasks:  
要限制并发任务的数量，请执行以下操作：

async def guarded_spell(semaphore, item):  
    async with semaphore:  
        print(f"Processing {item}")  
        await asyncio.sleep(1)  
async def main():  
    semaphore = asyncio.Semaphore(2)  # Allow 2 concurrent tasks  
    await asyncio.gather(*(guarded_spell(semaphore, i) for i in range(5)))  
asyncio.run(main())

# 10. Event Loops 10. 事件循环

To directly engage with the asynchronous loop, customizing the flow of execution:  
要直接与异步循环接合，请自定义执行流程：

async def perform_spell():  
    print("Casting spell...")  
    await asyncio.sleep(1)  
    print("Spell cast.")  
loop = asyncio.get_event_loop()  
try:  
    loop.run_until_complete(perform_spell())  
finally:  
    loop.close()

# Working With Networks, Sockets, and Network Interfaces  
使用网络、套接字和网络接口

# 1. Creating a Socket 1. 创建套接字

To create a socket for network communication:  
要创建用于网络通信的套接字，请执行以下操作：

import socket  
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 2. Connecting to a Remote Server  
2. 连接到远程服务器

To establish a link with a remote server through the socket:  
要通过套接字与远程服务器建立链接，请执行以下操作：

s.connect(('example.com', 80))  # Connect to example.com on port 80

# 3. Sending Data 3. 发送数据

To dispatch data through the network to a connected entity:  
要通过网络将数据调度到连接的实体，请执行以下操作：

s.sendall(b'Hello, server')

# 4. Receiving Data 4. 接收数据

To receive data from the network:  
要从网络接收数据，请执行以下操作：

data = s.recv(1024)  # Receive up to 1024 bytes  
print('Received', repr(data))

# 5. Closing a Socket 5. 关闭套接字

To gracefully close the socket, severing the network link:  
要正常关闭套接字，切断网络链接：

s.close()

# 6. Creating a Listening Socket  
6. 创建监听套接字

To open a socket that listens for incoming connections:  
要打开侦听传入连接的套接字，请执行以下操作：

serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  
serversocket.bind(('localhost', 8080))  # Bind to localhost on port 8080  
serversocket.listen()  # Listen for incoming connections

# 7. Accepting Connections 7. 接受连接

To accept and establish a network link:  
要接受并建立网络链接：

clientsocket, address = serversocket.accept()  
print(f"Connection from {address} has been established.")

# 8. Non-blocking Socket Operations  
8. 非阻塞套接字操作

To set a socket’s mode to non-blocking:  
要将套接字的模式设置为非阻塞：

s.setblocking(False)

# 9. Working with UDP Sockets  
9. 使用 UDP 套接字

To create a socket for UDP, a protocol for quicker, but less reliable communication:  
要为 UDP 创建套接字，这是一种用于更快但不太可靠的通信的协议：

udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  
udp_socket.bind(('localhost', 8081))  # Bind UDP socket to localhost on port 8081

# 10. Enumerating Network Interfaces  
10. 枚举网络接口

To discover the names and addresses of the machine’s network interfaces:  
要发现本机网络接口的名称和地址，请执行以下操作：

import socket  
import netifaces  
for interface in netifaces.interfaces():  
    addr = netifaces.ifaddresses(interface).get(netifaces.AF_INET)  
    if addr:  
        print(f"Interface: {interface}, Address: {addr[0]['addr']}")

#

# Working With Pandas Library (Dataframes)  
使用 Pandas 库（数据帧）

# 1. Creating a DataFrame 1. 创建 DataFrame

To create a DataFrame with your own columns and data:  
若要使用自己的列和数据创建 DataFrame，请执行以下操作：

import pandas as pd  
data = {  
    'Element': ['Earth', 'Water', 'Fire', 'Air'],  
    'Symbol': ['🜃', '🜄', '🜂', '🜁']  
}  
df = pd.DataFrame(data)

# 2. Reading Data from a CSV File  
2. 从 CSV 文件中读取数据

To read data from a CSV file, transforming it into a DataFrame:  
要从 CSV 文件中读取数据，并将其转换为 DataFrame，请执行以下操作：

df = pd.read_csv('elements.csv')

# 3. Inspecting the First Few Rows  
3. 检查前几行

To get first rows from dataframe:  
要从 DataFrame 获取第一行，请执行以下操作：

print(df.head())

# 4. Selecting Columns 4. 选择列

To select specific columns from dataframe:  
要从 DataFrame 中选择特定列，请执行以下操作：

symbols = df['Symbol']

# 5. Filtering Rows 5. 过滤行

To sift through the DataFrame, selecting rows that meet your criteria:  
要筛选 DataFrame，请选择符合条件的行：

fire_elements = df[df['Element'] == 'Fire']

# 6. Creating New Columns 6. 创建新列

To create new columns in DataFrame derived from the data within:  
若要在 DataFrame 中创建派生自以下数据的新列：

df['Length'] = df['Element'].apply(len)

# 7. Grouping and Aggregating Data  
7. 对数据进行分组和聚合

To gather your data into groups and extract new data through aggregation:  
要将数据收集到组中并通过聚合提取新数据，请执行以下操作：

element_groups = df.groupby('Element').agg({'Length': 'mean'})

# 8. Merging DataFrames 8. 合并数据帧

To weave together two DataFrames, joining them by a shared key:  
要将两个 DataFrame 编织在一起，请通过共享键将它们连接起来：

df2 = pd.DataFrame({'Element': ['Earth', 'Fire'], 'Quality': ['Solid', 'Plasma']})  
merged_df = pd.merge(df, df2, on='Element')

# 9. Handling Missing Data 9. 处理丢失的数据

To clean your DataFrame, filling the voids where data is absent:  
要清理 DataFrame，请填补缺少数据的空白：

df.fillna(value='Unknown', inplace=True)

# 10. Pivoting and Reshaping Data  
10. 转移和重塑数据

To transmute the shape of your DataFrame, revealing hidden patterns and structures with a pivot operation:  
要转换 DataFrame 的形状，使用透视操作显示隐藏的模式和结构，请执行以下操作：

pivoted_df = df.pivot(index='Element', columns='Symbol', values='Length')

# Working With Numpy Library (Arrays)  
使用 Numpy 库（数组）

# 1. Creating a NumPy Array  
1. 创建 NumPy 数组

To create an array: 要创建数组：

import numpy as np  
array = np.array([1, 2, 3, 4, 5])

# 2. Array of Zeros or Ones  
2. 零或一数组

To create an array filled with zeros:  
要创建一个充满零的数组：

zeros = np.zeros((3, 3))  # A 3x3 array of zeros  
ones = np.ones((2, 4))  # A 2x4 array of ones

# 3. Creating a Range of Numbers  
3. 创建数字范围

To create a sequence of numbers:  
要创建数字序列：

range_array = np.arange(10, 50, 5)  # From 10 to 50, step by 5

# 4. Creating a Linearly Spaced Array  
4. 创建线性间隔数组

To create a series of values, evenly spaced between two bounds:  
要创建一系列在两个边界之间均匀分布的值，请执行以下操作：

linear_spaced = np.linspace(0, 1, 5)  # 5 values from 0 to 1

# 5. Reshaping an Array 5. 重塑阵列

To transmute the shape of an array, altering its dimensions:  
要转换数组的形状，更改其尺寸：

reshaped = np.arange(9).reshape(3, 3)  # Reshape a 1D array into a 3x3 2D array

# 6. Basic Array Operations  
6. 基本阵列操作

To perform elemental manipulations upon the arrays:  
要对数组执行元素操作，请执行以下操作：

a = np.array([1, 2, 3])  
b = np.array([4, 5, 6])  
sum = a + b  # Element-wise addition  
difference = b - a  # Element-wise subtraction  
product = a * b  # Element-wise multiplication

# 7. Matrix Multiplication 7. 矩阵乘法

Basic dot product Operation:  
基本点积操作：

result = np.dot(a.reshape(1, 3), b.reshape(3, 1))  # Dot product of a and b

# 8. Accessing Array Elements  
8. 访问数组元素

Accessing array elements with useful syntax:  
使用有用的语法访问数组元素：

element = a[2]  # Retrieve the third element of array 'a'  
row = reshaped[1, :]  # Retrieve the second row of 'reshaped'

# 9. Boolean Indexing 9. 布尔索引

To filter the elements of an array through the sieve of conditionals:  
要通过条件句的筛子过滤数组的元素，请执行以下操作：

filtered = a[a > 2]  # Elements of 'a' greater than 2

# 10. Aggregations and Statistics  
10. 汇总和统计

Statistical operations on np arrays:  
np 数组的统计操作：

mean = np.mean(a)  
maximum = np.max(a)  
sum = np.sum(a)

# Working With Matplotlib Library (Data Visualization)  
使用 Matplotlib 库（数据可视化）

# 1. Creating a Basic Plot  
1. 创建基本绘图

To create a plot visualization:  
要创建绘图可视化效果，请执行以下操作：

import matplotlib.pyplot as plt  
x = [1, 2, 3, 4, 5]  
y = [1, 4, 9, 16, 25]  
plt.plot(x, y)  
plt.show()

# 2. Adding Titles and Labels  
2. 添加标题和标签

To create names for axes and title your plot to give better context:  
要为轴创建名称并为您的绘图命名以提供更好的上下文，请执行以下操作：

plt.plot(x, y)  
plt.title('Growth Over Time')  
plt.xlabel('Time')  
plt.ylabel('Growth')  
plt.show()

# 3. Creating a Scatter Plot  
3. 创建散点图

Creating a scatter plot: 创建散点图：

plt.scatter(x, y)  
plt.show()

# 4. Customizing Line Styles and Markers  
4. 自定义线型和标记

To add symbols into your plot, enriching its usefulness:  
要将符号添加到绘图中，以丰富其实用性：

plt.plot(x, y, linestyle='--', marker='o', color='b')  
plt.show()

# 5. Creating Multiple Plots on the Same Axes  
5. 在同一轴上创建多个绘图

Creating Multiple Plots on the Same Axes:  
在同一轴上创建多个绘图：

z = [2, 3, 4, 5, 6]  
plt.plot(x, y)  
plt.plot(x, z)  
plt.show()

# 6. Creating Subplots 6. 创建子图

To create subplots: 要创建子图：

fig, ax = plt.subplots(2, 1)  # 2 rows, 1 column  
ax[0].plot(x, y)  
ax[1].plot(x, z)  
plt.show()

# 7. Creating a Histogram 7. 创建直方图

To create a histogram: 要创建直方图，请执行以下操作：

data = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]  
plt.hist(data, bins=4)  
plt.show()

# 8. Adding a Legend 8. 添加图例

To create a legend for the plot:  
要为绘图创建图例，请执行以下操作：

plt.plot(x, y, label='Growth')  
plt.plot(x, z, label='Decay')  
plt.legend()  
plt.show()

# 9. Customizing Ticks 9. 自定义刻度

To create your own marks upon the axes, defining the scale of your values:  
要在轴上创建自己的标记，定义值的刻度，请执行以下操作：

plt.plot(x, y)  
plt.xticks([1, 2, 3, 4, 5], ['One', 'Two', 'Three', 'Four', 'Five'])  
plt.yticks([0, 5, 10, 15, 20, 25], ['0', '5', '10', '15', '20', '25+'])  
plt.show()

# 10. Saving Figures 10. 储蓄数字

To save the plot as a .png:  
要将绘图另存为.png：

plt.plot(x, y)  
plt.savefig('growth_over_time.png')

# Working With Scikit-Learn Library (Machine Learning)  
使用 Scikit-Learn 库（机器学习）

# 1. Loading a Dataset 1. 加载数据集

To work with datasets for your ML experiments  
使用数据集进行 ML 实验

from sklearn import datasets  
iris = datasets.load_iris()  
X, y = iris.data, iris.target

# 2. Splitting Data into Training and Test Sets  
2. 将数据拆分为训练集和测试集

To divide your data, dedicating portions to training and evaluation:  
要划分数据，将部分专用于训练和评估，请执行以下操作：

from sklearn.model_selection import train_test_split  
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

# 3. Training a Model 3. 训练模型

Training a ML Model using RandomForestClassifier:  
使用 RandomForestClassifier 训练 ML 模型：

from sklearn.ensemble import RandomForestClassifier  
model = RandomForestClassifier()  
model.fit(X_train, y_train)

# 4. Making Predictions 4. 做出预测

To access the model predictions:  
要访问模型预测，请执行以下操作：

predictions = model.predict(X_test)

# 5. Evaluating Model Performance  
5. 评估模型性能

To evaluate your model, measuring its accuracy in prediction:  
要评估模型，测量其预测准确性，请执行以下操作：

from sklearn.metrics import accuracy_score  
accuracy = accuracy_score(y_test, predictions)  
print(f"Model accuracy: {accuracy}")

# 6. Using Cross-Validation  
6. 使用交叉验证

To use Cross-Validation: 要使用交叉验证，请执行以下操作：

from sklearn.model_selection import cross_val_score  
scores = cross_val_score(model, X, y, cv=5)  
print(f"Cross-validation scores: {scores}")

# 7. Feature Scaling 7. 功能缩放

To create the appropriate scales of your features, allowing the model to learn more effectively:  
要创建适当的特征比例，使模型能够更有效地学习，请执行以下操作：

from sklearn.preprocessing import StandardScaler  
scaler = StandardScaler()  
X_train_scaled = scaler.fit_transform(X_train)  
X_test_scaled = scaler.transform(X_test)

# 8. Parameter Tuning with Grid Search  
8. 使用网格搜索进行参数调整

To refine your model’s parameters, seeking the optimal combination:  
要优化模型的参数，寻求最佳组合，请执行以下操作：

from sklearn.model_selection import GridSearchCV  
param_grid = {'n_estimators': [10, 50, 100], 'max_depth': [None, 10, 20]}  
grid_search = GridSearchCV(model, param_grid, cv=5)  
grid_search.fit(X_train, y_train)

# 9. Pipeline Creation 9. 管道创建

To streamline your data processing and modeling steps, crafting a seamless flow:  
要简化数据处理和建模步骤，打造无缝流程，请执行以下操作：

from sklearn.pipeline import Pipeline  
pipeline = Pipeline([  
    ('scaler', StandardScaler()),  
    ('classifier', RandomForestClassifier())  
])  
pipeline.fit(X_train, y_train)

# 10. Saving and Loading a Model  
10. 保存和加载模型

To preserve your model: 要保留模型，请执行以下操作：

import joblib  
# Saving the model  
joblib.dump(model, 'model.joblib')  
# Loading the model  
loaded_model = joblib.load('model.joblib')

# Working With Plotly Library (Interactive Data Visualization)  
使用 Plotly 库（交互式数据可视化）

# 1. Creating a Basic Line Chart  
1. 创建基本折线图

To create a line chart:  
要创建折线图：

import plotly.graph_objs as go  
import plotly.io as pio  
x = [1, 2, 3, 4, 5]  
y = [1, 4, 9, 16, 25]  
fig = go.Figure(data=go.Scatter(x=x, y=y, mode='lines'))  
pio.show(fig)

# 2. Creating a Scatter Plot  
2. 创建散点图

To create a scatter plot:  
要创建散点图，请执行以下操作：

fig = go.Figure(data=go.Scatter(x=x, y=y, mode='markers'))  
pio.show(fig)

# 3. Creating a Bar Chart  
3. 创建条形图

To Create a Bar Chart:  
要创建条形图：

categories = ['A', 'B', 'C', 'D', 'E']  
values = [10, 20, 15, 30, 25]  
fig = go.Figure(data=go.Bar(x=categories, y=values))  
pio.show(fig)

# 4. Creating a Pie Chart  
4. 创建饼图

To create a Pie Chart:  
要创建饼图：

labels = ['Earth', 'Water', 'Fire', 'Air']  
sizes = [25, 35, 20, 20]  
fig = go.Figure(data=go.Pie(labels=labels, values=sizes))  
pio.show(fig)

# 5. Creating a Histogram 5. 创建直方图

To create a Histogram: 要创建直方图：

data = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]  
fig = go.Figure(data=go.Histogram(x=data))  
pio.show(fig)

# 6. Creating Box Plots 6. 创建箱形图

To create a Box Plot:  
要创建箱形图：

data = [1, 2, 2, 3, 4, 4, 4, 5, 5, 6]  
fig = go.Figure(data=go.Box(y=data))  
pio.show(fig)

# 7. Creating Heatmaps 7. 创建热图

To create a heatmap: 要创建热图，请执行以下操作：

import numpy as np  
z = np.random.rand(10, 10)  # Generate random data  
fig = go.Figure(data=go.Heatmap(z=z))  
pio.show(fig)

# 8. Creating 3D Surface Plots  
8. 创建 3D 曲面图

To create a 3D Surface Plot:  
要创建 3D 曲面图：

z = np.random.rand(20, 20)  # Generate random data  
fig = go.Figure(data=go.Surface(z=z))  
pio.show(fig)

# 9. Creating Subplots 9. 创建子图

To create a subplot: 要创建子图：

from plotly.subplots import make_subplots  
fig = make_subplots(rows=1, cols=2)  
fig.add_trace(go.Scatter(x=x, y=y, mode='lines'), row=1, col=1)  
fig.add_trace(go.Bar(x=categories, y=values), row=1, col=2)  
pio.show(fig)

# 10. Creating Interactive Time Series  
10. 创建交互式时间序列

To work with Time Series:  
要使用时间序列，请执行以下操作：

import pandas as pd  
dates = pd.date_range('20230101', periods=5)  
values = [10, 11, 12, 13, 14]  
fig = go.Figure(data=go.Scatter(x=dates, y=values, mode='lines+markers'))  
pio.show(fig)

# Working With Dates and Times  
使用日期和时间

# 1. Getting the Current Date and Time  
1. 获取当前日期和时间

To get the current data and time:  
要获取当前数据和时间，请执行以下操作：

from datetime import datetime  
now = datetime.now()  
print(f"Current date and time: {now}")

# 2. Creating Specific Date and Time  
2. 创建特定日期和时间

To conjure a moment from the past or future, crafting it with precision:  
从过去或未来召唤出一个时刻，精确地制作它：

specific_time = datetime(2023, 1, 1, 12, 30)  
print(f"Specific date and time: {specific_time}")

# 3. Formatting Dates and Times  
3. 格式化日期和时间

Formatting Dates and Times:  
格式化日期和时间：

formatted = now.strftime("%Y-%m-%d %H:%M:%S")  
print(f"Formatted date and time: {formatted}")

# 4. Parsing Dates and Times from Strings  
4. 从字符串中解析日期和时间

Parsing Dates and Times from Strings:  
从字符串中解析日期和时间：

date_string = "2023-01-01 15:00:00"  
parsed_date = datetime.strptime(date_string, "%Y-%m-%d %H:%M:%S")  
print(f"Parsed date and time: {parsed_date}")

# 5. Working with Time Deltas  
5. 使用时间增量

To traverse the distances between moments, leaping forward or backward through time:  
要穿越时刻之间的距离，在时间中向前或向后跳跃：

from datetime import timedelta  
delta = timedelta(days=7)  
future_date = now + delta  
print(f"Date after 7 days: {future_date}")

# 6. Comparing Dates and Times  
6. 比较日期和时间

Date and Times comparisons:  
日期和时间比较：

if specific_time > now:  
    print("Specific time is in the future.")  
else:  
    print("Specific time has passed.")

# 7. Extracting Components from a Date/Time  
7. 从日期/时间中提取组件

To extract dates year, month, day, and more:  
要提取日期、年、月、日等：

year = now.year  
month = now.month  
day = now.day  
hour = now.hour  
minute = now.minute  
second = now.second  
print(f"Year: {year}, Month: {month}, Day: {day}, Hour: {hour}, Minute: {minute}, Second: {second}")

# 8. Working with Time Zones  
8. 使用时区

To work with time zones honoring the local time:  
要使用遵循当地时间的时区：

from datetime import timezone, timedelta  
utc_time = datetime.now(timezone.utc)  
print(f"Current UTC time: {utc_time}")  
# Adjusting to a specific timezone (e.g., EST)  
est_time = utc_time - timedelta(hours=5)  
print(f"Current EST time: {est_time}")

# 9. Getting the Weekday 9. 获取工作日

To identify the day of the week:  
要确定星期几：

weekday = now.strftime("%A")  
print(f"Today is: {weekday}")

# 10. Working with Unix Timestamps  
10. 使用 Unix 时间戳

To converse with the ancient epochs, translating their count from the dawn of Unix:  
与古代时代交谈，从Unix的黎明开始翻译他们的计数：

timestamp = datetime.timestamp(now)  
print(f"Current timestamp: {timestamp}")  
# Converting a timestamp back to a datetime  
date_from_timestamp = datetime.fromtimestamp(timestamp)  
print(f"Date from timestamp: {date_from_timestamp}")

# Working With More Advanced List Comprehensions and Lambda Functions  
使用更高级的列表推导式和 Lambda 函数

# 1. Nested List Comprehensions  
1. 嵌套列表推导

To work with nested list Comprehensions:  
要使用嵌套列表推导式：

matrix = [[j for j in range(5)] for i in range(3)]  
print(matrix)  # Creates a 3x5 matrix

# 2. Conditional List Comprehensions  
2. 条件列表推导

To filter elements that meet your criteria:  
要筛选符合条件的元素，请执行以下操作：

filtered = [x for x in range(10) if x % 2 == 0]  
print(filtered)  # Even numbers from 0 to 9

# 3. List Comprehensions with Multiple Iterables  
3. 列出具有多个可迭代项的推导

To merge and transform elements from multiple sources in a single dance:  
要在单个舞蹈中合并和转换来自多个来源的元素：

pairs = [(x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x != y]  
print(pairs)  # Pairs of non-equal elements

# 4. Using Lambda Functions  
4. 使用 Lambda 函数

To summon anonymous functions, ephemeral and concise, for a single act of magic:  
召唤匿名函数，短暂而简洁，用于单一的魔法行为：

square = lambda x: x**2  
print(square(5))  # Returns 25

# 5. Lambda Functions in List Comprehensions  
5. 列表推导中的 Lambda 函数

To employ lambda functions within your list comprehensions:  
要在列表推导式中使用 lambda 函数，请执行以下操作：

squared = [(lambda x: x**2)(x) for x in range(5)]  
print(squared)  # Squares of numbers from 0 to 4

# 6. List Comprehensions for Flattening Lists  
6. 扁平化列表的列表推导

To flatten a nested list, spreading its elements into a single dimension:  
要展平嵌套列表，将其元素分散到单个维度中，请执行以下操作：

nested = [[1, 2, 3], [4, 5], [6, 7]]  
flattened = [x for sublist in nested for x in sublist]  
print(flattened)

# 7. Applying Functions to Elements  
7. 将函数应用于元素

To apply a transformation function to each element:  
要将转换函数应用于每个元素，请执行以下操作：

import math  
transformed = [math.sqrt(x) for x in range(1, 6)]  
print(transformed)  # Square roots of numbers from 1 to 5

# 8. Using Lambda with Map and Filter  
8. 将 Lambda 与地图和过滤器结合使用

To map and filter lists:  
要映射和筛选列表，请执行以下操作：

mapped = list(map(lambda x: x**2, range(5)))  
filtered = list(filter(lambda x: x > 5, mapped))  
print(mapped)    # Squares of numbers from 0 to 4  
print(filtered)  # Elements greater than 5

# 9. List Comprehensions with Conditional Expressions  
9. 使用条件表达式列出推导

List Comprehensions with Condidtional Expressions:  
使用条件表达式列出理解：

conditional = [x if x > 2 else x**2 for x in range(5)]  
print(conditional)  # Squares numbers less than or equal to 2, passes others unchanged

# 10. Complex Transformations with Lambda  
10. 使用 Lambda 进行复杂转换

To conduct intricate transformations, using lambda functions:  
要使用 lambda 函数执行复杂的转换，请执行以下操作：

complex_transformation = list(map(lambda x: x**2 if x % 2 == 0 else x + 5, range(5)))  
print(complex_transformation)  # Applies different transformations based on even-odd condition

# Working With Object Oriented Programming  
使用面向对象编程

# 1. Defining a Class 1. 定义类

Creating a class: 创建类：

class Wizard:  
    def __init__(self, name, power):  
        self.name = name  
        self.power = power  
   def cast_spell(self):  
        print(f"{self.name} casts a spell with power {self.power}!")

# 2. Creating an Instance 2. 创建实例

To create an instance of your class:  
要创建类的实例，请执行以下操作：

merlin = Wizard("Merlin", 100)

# 3. Invoking Methods 3. 调用方法

To call methods on instance of class:  
要在类的实例上调用方法：

merlin.cast_spell()

# 4. Inheritance 4. 继承

Subclassing: 子类：

class ArchWizard(Wizard):  
    def __init__(self, name, power, realm):  
        super().__init__(name, power)  
        self.realm = realm  
    def summon_familiar(self):  
        print(f"{self.name} summons a familiar from the {self.realm} realm.")

# 5. Overriding Methods 5. 覆盖方法

To overide base classes: 要覆盖基类，请执行以下操作：

class Sorcerer(Wizard):  
    def cast_spell(self):  
        print(f"{self.name} casts a powerful dark spell!")

# 6. Polymorphism 6. 多态性

To interact with different forms through a common interface:  
要通过通用界面与不同的表单进行交互，请执行以下操作：

def unleash_magic(wizard):  
    wizard.cast_spell()  
unleash_magic(merlin)  
unleash_magic(Sorcerer("Voldemort", 90))

# 7. Encapsulation 7. 封装

To use information hiding:  
要使用信息隐藏：

class Alchemist:  
    def __init__(self, secret_ingredient):  
        self.__secret = secret_ingredient  
    def reveal_secret(self):  
        print(f"The secret ingredient is {self.__secret}")

# 8. Composition 8. 组成

To assemble Objects from simpler ones:  
要从更简单的对象组装对象：

class Spellbook:  
    def __init__(self, spells):  
        self.spells = spells  
class Mage:  
    def __init__(self, name, spellbook):  
        self.name = name  
        self.spellbook = spellbook

# 9. Class Methods and Static Methods  
9. 类方法和静态方法

To bind actions to the class itself or liberate them from the instance, serving broader purposes:  
要将操作绑定到类本身或将它们从实例中解放出来，以服务于更广泛的目的：

class Enchanter:  
    @staticmethod  
    def enchant(item):  
        print(f"{item} is enchanted!")  
    @classmethod  
    def summon(cls):  
        print("A new enchanter is summoned.")

# 10. Properties and Setters  
10. 属性和设置器

To elegantly manage access to an entity’s attributes, guiding their use and protection:  
要优雅地管理对实体属性的访问，指导其使用和保护，请执行以下操作：

class Elementalist:  
    def __init__(self, element):  
        self._element = element  
    @property  
    def element(self):  
        return self._element  
   @element.setter  
    def element(self, value):  
        if value in ["Fire", "Water", "Earth", "Air"]:  
            self._element = value  
        else:  
            print("Invalid element!")

# Working With Decorators 使用装饰器

# 1. Basic Decorator 1. 基本装饰器

To create a simple decorator that wraps a function:  
要创建包装函数的简单装饰器，请执行以下操作：

def my_decorator(func):  
    def wrapper():  
        print("Something is happening before the function is called.")  
        func()  
        print("Something is happening after the function is called.")  
    return wrapper

@my_decorator  
def say_hello():  
    print("Hello!")say_hello()

# 2. Decorator with Arguments  
2. 带参数的装饰器

To pass arguments to the function within a decorator:  
若要将参数传递给装饰器中的函数，请执行以下操作：

def my_decorator(func):  
    def wrapper(*args, **kwargs):  
        print("Before call")  
        result = func(*args, **kwargs)  
        print("After call")  
        return result  
    return wrapper

@my_decorator  
def greet(name):  
    print(f"Hello {name}")greet("Alice")

# 3. Using functools.wraps 3.使用 functools.wraps

To preserve the metadata of the original function when decorating:  
要在装饰时保留原始函数的元数据：

from functools import wraps

def my_decorator(func):  
    @wraps(func)  
    def wrapper(*args, **kwargs):  
        """Wrapper function"""  
        return func(*args, **kwargs)  
    return wrapper@my_decorator  
def greet(name):  
    """Greet someone"""  
    print(f"Hello {name}")print(greet.__name__)  # Outputs: 'greet'  
print(greet.__doc__)   # Outputs: 'Greet someone'

# 4. Class Decorator 4. 类装饰器

To create a decorator using a class:  
要使用类创建装饰器，请执行以下操作：

class MyDecorator:  
    def __init__(self, func):  
        self.func = func  
   def __call__(self, *args, **kwargs):  
        print("Before call")  
        self.func(*args, **kwargs)  
        print("After call")

@MyDecorator  
def greet(name):  
    print(f"Hello {name}")greet("Alice")

# 5. Decorator with Arguments  
5. 带参数的装饰器

To create a decorator that accepts its own arguments:  
要创建接受其自身参数的装饰器，请执行以下操作：

def repeat(times):  
    def decorator(func):  
        @wraps(func)  
        def wrapper(*args, **kwargs):  
            for _ in range(times):  
                func(*args, **kwargs)  
        return wrapper  
    return decorator

@repeat(3)  
def say_hello():  
    print("Hello")say_hello()

# 6. Method Decorator 6. 方法装饰器

To apply a decorator to a method within a class:  
若要将修饰器应用于类中的方法，请执行以下操作：

def method_decorator(func):  
    @wraps(func)  
    def wrapper(self, *args, **kwargs):  
        print("Method Decorator")  
        return func(self, *args, **kwargs)  
    return wrapper

class MyClass:  
    @method_decorator  
    def greet(self, name):  
        print(f"Hello {name}")obj = MyClass()  
obj.greet("Alice")

# 7. Stacking Decorators 7. 堆垛装饰器

To apply multiple decorators to a single function:  
要将多个装饰器应用于单个函数，请执行以下操作：

@my_decorator  
@repeat(2)  
def greet(name):  
    print(f"Hello {name}")

greet("Alice")

# 8. Decorator with Optional Arguments  
8. 具有可选参数的装饰器

Creating a decorator that works with or without arguments:  
创建带或不带参数的装饰器：

def smart_decorator(arg=None):  
    def decorator(func):  
        @wraps(func)  
        def wrapper(*args, **kwargs):  
            if arg:  
                print(f"Argument: {arg}")  
            return func(*args, **kwargs)  
        return wrapper  
    if callable(arg):  
        return decorator(arg)  
    return decorator

@smart_decorator  
def no_args():  
    print("No args")@smart_decorator("With args")  
def with_args():  
    print("With args")no_args()  
with_args()

# 9. Class Method Decorator  
9. 类方法装饰器

To decorate a class method:  
要修饰类方法，请执行以下操作：

class MyClass:  
    @classmethod  
    @my_decorator  
    def class_method(cls):  
        print("Class method called")

MyClass.class_method()

# 10. Decorator for Static Method  
10. 静态方法的装饰器

To decorate a static method:  
要装饰静态方法，请执行以下操作：

class MyClass:  
    @staticmethod  
    @my_decorator  
    def static_method():  
        print("Static method called")

MyClass.static_method()

# Working With GraphQL 使用 GraphQL

# 1. Setting Up a GraphQL Client  
1. 设置 GraphQL 客户端

To work with GraphQL: 要使用 GraphQL，请执行以下操作：

from gql import gql, Client  
from gql.transport.requests import RequestsHTTPTransport  
transport = RequestsHTTPTransport(url='https://your-graphql-endpoint.com/graphql')  
client = Client(transport=transport, fetch_schema_from_transport=True)

# 2. Executing a Simple Query  
2. 执行简单查询

Executing a Query: 执行查询：

query = gql('''  
{  
  allWizards {  
    id  
    name  
    power  
  }  
}  
''')

result = client.execute(query)  
print(result)

# 3. Executing a Query with Variables  
3. 使用变量执行查询

Query with Variables: 使用变量查询：

query = gql('''  
query GetWizards($element: String!) {  
  wizards(element: $element) {  
    id  
    name  
  }  
}  
''')  
params = {"element": "Fire"}  
result = client.execute(query, variable_values=params)  
print(result)

# 4. Mutations 4. 突变

To create and execute a mutation:  
要创建并执行突变，请执行以下操作：

mutation = gql('''  
mutation CreateWizard($name: String!, $element: String!) {  
  createWizard(name: $name, element: $element) {  
    wizard {  
      id  
      name  
    }  
  }  
}  
''')  
params = {"name": "Gandalf", "element": "Light"}  
result = client.execute(mutation, variable_values=params)  
print(result)

# 5. Handling Errors 5. 处理错误

Error handling: 错误处理：

from gql import gql, Client  
from gql.transport.exceptions import TransportQueryError  
try:  
    result = client.execute(query)  
except TransportQueryError as e:  
    print(f"GraphQL Query Error: {e}")

# 6. Subscriptions 6. 订阅

Working with Subscriptions:  
使用订阅：

subscription = gql('''  
subscription {  
  wizardUpdated {  
    id  
    name  
    power  
  }  
}  
''')  
for result in client.subscribe(subscription):  
    print(result)

# 7. Fragments 7. 碎片

Working with Fragments: 使用片段：

query = gql('''  
fragment WizardDetails on Wizard {  
  name  
  power  
}  
query {  
  allWizards {  
    ...WizardDetails  
  }  
}  
''')  
result = client.execute(query)  
print(result)

# 8. Inline Fragments 8. 内联片段

To tailor the response based on the type of the object returned:  
要根据返回的对象类型定制响应，请执行以下操作：

query = gql('''  
{  
  search(text: "magic") {  
    __typename  
    ... on Wizard {  
      name  
      power  
    }  
    ... on Spell {  
      name  
      effect  
    }  
  }  
}  
''')  
result = client.execute(query)  
print(result)

# 9. Using Directives 9. 使用指令

To dynamically include or skip fields in your queries based on conditions:  
要根据条件在查询中动态包含或跳过字段，请执行以下操作：

query = gql('''  
query GetWizards($withPower: Boolean!) {  
  allWizards {  
    name  
    power @include(if: $withPower)  
  }  
}  
''')  
params = {"withPower": True}  
result = client.execute(query, variable_values=params)  
print(result)

# 10. Batching Requests 10. 批处理请求

To combine multiple operations into a single request, reducing network overhead:  
要将多个操作合并到单个请求中，从而减少网络开销，请执行以下操作：

from gql import gql, Client  
from gql.transport.requests import RequestsHTTPTransport

transport = RequestsHTTPTransport(url='https://your-graphql-endpoint.com/graphql', use_json=True)  
client = Client(transport=transport, fetch_schema_from_transport=True)query1 = gql('query { wizard(id: "1") { name } }')  
query2 = gql('query { allSpells { name } }')results = client.execute([query1, query2])  
print(results)

# Working With Regular Expressions  
使用正则表达式

# 1. Basic Pattern Matching  
1. 基本模式匹配

To find a match for a pattern within a string:  
要查找字符串中模式的匹配项，请执行以下操作：

import re  
text = "Search this string for patterns."  
match = re.search(r"patterns", text)  
if match:  
    print("Pattern found!")

# 2. Compiling Regular Expressions  
2. 编译正则表达式

To compile a regular expression for repeated use:  
要编译正则表达式以供重复使用：

pattern = re.compile(r"patterns")  
match = pattern.search(text)

# 3. Matching at the Beginning or End  
3. 开头或结尾的匹配

To check if a string starts or ends with a pattern:  
要检查字符串是否以模式开头或结尾：

if re.match(r"^Search", text):  
    print("Starts with 'Search'")  
if re.search(r"patterns.$", text):  
    print("Ends with 'patterns.'")

# 4. Finding All Matches 4. 查找所有匹配项

To find all occurrences of a pattern in a string:  
要查找字符串中模式的所有匹配项，请执行以下操作：

all_matches = re.findall(r"t\w+", text)  # Finds words starting with 't'  
print(all_matches)

# 5. Search and Replace (Substitution)  
5. 搜索和替换（替换）

To replace occurrences of a pattern within a string:  
要替换字符串中出现的模式，请执行以下操作：

replaced_text = re.sub(r"string", "sentence", text)  
print(replaced_text)

# 6. Splitting a String 6. 拆分字符串

To split a string by occurrences of a pattern:  
要按模式的出现次数拆分字符串，请执行以下操作：

words = re.split(r"\s+", text)  # Split on one or more spaces  
print(words)

# 7. Escaping Special Characters  
7. 转义特殊字符

To match special characters literally, escape them:  
要从字面上匹配特殊字符，请转义它们：

escaped = re.search(r"\bfor\b", text)  # \b is a word boundary

# 8. Grouping and Capturing  
8. 分组和捕获

To group parts of a pattern and extract their values:  
要对模式的各个部分进行分组并提取其值，请执行以下操作：

match = re.search(r"(\w+) (\w+)", text)  
if match:  
    print(match.group())  # The whole match  
    print(match.group(1)) # The first group

# 9. Non-Capturing Groups 9. 非捕获组

To define groups without capturing them:  
要定义组而不捕获组：

match = re.search(r"(?:\w+) (\w+)", text)  
if match:  
    print(match.group(1))  # The first (and only) group

# 10. Lookahead and Lookbehind Assertions  
10. 前瞻和后瞻断言

To match a pattern based on what comes before or after it without including it in the result:  
要根据模式之前或之后的内容来匹配模式，而不将其包含在结果中，请执行以下操作：

lookahead = re.search(r"\b\w+(?= string)", text)  # Word before ' string'  
lookbehind = re.search(r"(?<=Search )\w+", text)  # Word after 'Search '  
if lookahead:  
    print(lookahead.group())  
if lookbehind:  
    print(lookbehind.group())

# 11. Flags to Modify Pattern Matching Behavior  
11. 修改模式匹配行为的标志

To use flags like `re.IGNORECASE` to change how patterns are matched:  
要使用标志来 `re.IGNORECASE` 更改模式的匹配方式，请执行以下操作：

case_insensitive = re.findall(r"search", text, re.IGNORECASE)  
print(case_insensitive)

# 12. Using Named Groups 12. 使用命名组

To assign names to groups and reference them by name:  
要为组分配名称并按名称引用它们，请执行以下操作：

match = re.search(r"(?P<first>\w+) (?P<second>\w+)", text)  
if match:  
    print(match.group('first'))  
    print(match.group('second'))

# 13. Matching Across Multiple Lines  
13. 跨多行匹配

To match patterns over multiple lines using the `re.MULTILINE` flag:  
要使用 `re.MULTILINE` 标志在多行上匹配模式，请执行以下操作：

multi_line_text = "Start\nmiddle end"  
matches = re.findall(r"^m\w+", multi_line_text, re.MULTILINE)  
print(matches)

# 14. Lazy Quantifiers 14. 懒惰量词

To match as few characters as possible using lazy quantifiers (`*?`, `+?`, `??`):  
要使用惰性量词 （ `*?` ， `+?` ， ） `??` 匹配尽可能少的字符：

html = "<body><h1>Title</h1></body>"  
match = re.search(r"<.*?>", html)  
if match:  
    print(match.group())  # Matches '<body>'

# 15. Verbose Regular Expressions  
15. 详细正则表达式

To use `re.VERBOSE` for more readable regular expressions:  
要用于 `re.VERBOSE` 可读性更强的正则表达式，请执行以下操作：

pattern = re.compile(r"""  
    \b      # Word boundary  
    \w+     # One or more word characters  
    \s      # Space  
    """, re.VERBOSE)  
match = pattern.search(text)

# Working With Strings 使用字符串

# 1. Concatenating Strings 1. 串联字符串

To join strings together:  
要将字符串连接在一起，请执行以下操作：

greeting = "Hello"  
name = "Alice"  
message = greeting + ", " + name + "!"  
print(message)

# 2. String Formatting with `str.format`  
2. 字符串 `str.format` 格式化

To insert values into a string template:  
要将值插入到字符串模板中：

message = "{}, {}. Welcome!".format(greeting, name)  
print(message)

# 3. Formatted String Literals (f-strings)  
3. 格式化字符串文字（f 字符串）

To embed expressions inside string literals (Python 3.6+):  
要在字符串文本中嵌入表达式 （Python 3.6+）：

message = f"{greeting}, {name}. Welcome!"  
print(message)

# 4. String Methods — Case Conversion  
4. 字符串方法 — 大小写转换

To change the case of a string:  
要更改字符串的大小写，请执行以下操作：

s = "Python"  
print(s.upper())  # Uppercase  
print(s.lower())  # Lowercase  
print(s.title())  # Title Case

# 5. String Methods — `strip`, `rstrip`, `lstrip`  
5. 字符串方法 — `strip` ， `rstrip` ， `lstrip`

To remove whitespace or specific characters from the ends of a string:  
要删除字符串末尾的空格或特定字符，请执行以下操作：

s = "   trim me   "  
print(s.strip())   # Both ends  
print(s.rstrip())  # Right end  
print(s.lstrip())  # Left end

# 6. String Methods — `startswith`, `endswith`  
6. 字符串方法 — `startswith` ， `endswith`

To check the start or end of a string for specific text:  
要检查特定文本的字符串的开头或结尾：

s = "filename.txt"  
print(s.startswith("file"))  # True  
print(s.endswith(".txt"))    # True

# 7. String Methods — `split`, `join`  
7. 字符串方法 — `split` ， `join`

To split a string into a list or join a list into a string:  
要将字符串拆分为列表或将列表联接到字符串中，请执行以下操作：

s = "split,this,string"  
words = s.split(",")        # Split string into list  
joined = " ".join(words)    # Join list into string  
print(words)  
print(joined)

# 8. String Methods — `replace`  
8. 字符串方法 — `replace`

To replace parts of a string with another string:  
要将字符串的某些部分替换为另一个字符串：

s = "Hello world"  
new_s = s.replace("world", "Python")  
print(new_s)

# 9. String Methods — `find`, `index`  
9. 字符串方法 — `find` ， `index`

To find the position of a substring within a string:  
要查找子字符串在字符串中的位置，请执行以下操作：

s = "look for a substring"  
position = s.find("substring")  # Returns -1 if not found  
index = s.index("substring")    # Raises ValueError if not found  
print(position)  
print(index)

# 10. String Methods — Working with Characters  
10. 字符串方法 — 使用字符

To process individual characters in a string:  
要处理字符串中的单个字符，请执行以下操作：

s = "characters"  
for char in s:  
    print(char)  # Prints each character on a new line

# 11. String Methods — `isdigit`, `isalpha`, `isalnum`  
11. 字符串方法 — `isdigit` ， `isalpha` ， `isalnum`

To check if a string contains only digits, alphabetic characters, or alphanumeric characters:  
要检查字符串是否仅包含数字、字母字符或字母数字字符：

print("123".isdigit())   # True  
print("abc".isalpha())   # True  
print("abc123".isalnum())# True

# 12. String Slicing 12. 字符串切片

To extract a substring using slicing:  
要使用切片提取子字符串，请执行以下操作：

s = "slice me"  
sub = s[2:7]  # From 3rd to 7th character  
print(sub)

# 13. String Length with `len`  
13. 字符串长度 `len`

To get the length of a string:  
要获取字符串的长度，请执行以下操作：

s = "length"  
print(len(s))  # 6

# 14. Multiline Strings 14. 多行字符串

To work with strings spanning multiple lines:  
要处理跨多行的字符串，请执行以下操作：

multi = """Line one  
Line two  
Line three"""  
print(multi)

# 15. Raw Strings 15. 原始字符串

To treat backslashes as literal characters, useful for regex patterns and file paths:  
要将反斜杠视为文字字符，对于正则表达式模式和文件路径很有用：

path = r"C:\User\name\folder"  
print(path)

# Working With Web Scraping  
使用网页抓取

# 1. Fetching Web Pages with `requests`  
1. 获取网页 `requests`

To retrieve the content of a web page:  
要检索网页的内容，请执行以下操作：

import requests

url = 'https://example.com'  
response = requests.get(url)  
html = response.text

# 2. Parsing HTML with `BeautifulSoup`  
2. 解 `BeautifulSoup` 析 HTML

To parse HTML and extract data:  
要解析 HTML 并提取数据，请执行以下操作：

from bs4 import BeautifulSoup  
soup = BeautifulSoup(html, 'html.parser')  
print(soup.prettify())  # Pretty-print the HTML

# 3. Navigating the HTML Tree  
3. 浏览 HTML 树

To find elements using tags:  
要使用标签查找元素，请执行以下操作：

title = soup.title.text  # Get the page title  
headings = soup.find_all('h1')  # List of all <h1> tags

# 4. Using CSS Selectors 4. 使用 CSS 选择器

To select elements using CSS selectors:  
要使用 CSS 选择器选择元素：

articles = soup.select('div.article')  # All elements with class 'article' inside a <div>

# 5. Extracting Data from Tags  
5. 从标签中提取数据

To extract text and attributes from HTML elements:  
要从 HTML 元素中提取文本和属性：

for article in articles:  
    title = article.h2.text  # Text inside the <h2> tag  
    link = article.a['href']  # 'href' attribute of the <a> tag  
    print(title, link)

# 6. Handling Relative URLs  
6. 处理相对 URL

To convert relative URLs to absolute URLs:  
要将相对 URL 转换为绝对 URL，请执行以下操作：

from urllib.parse import urljoin  
absolute_urls = [urljoin(url, link) for link in relative_urls]

# 7. Dealing with Pagination  
7. 处理分页

To scrape content across multiple pages:  
要跨多个页面抓取内容：

base_url = "https://example.com/page/"  
for page in range(1, 6):  # For 5 pages  
    page_url = base_url + str(page)  
    response = requests.get(page_url)  
    # Process each page's content

# 8. Handling AJAX Requests  
8. 处理 AJAX 请求

To scrape data loaded by AJAX requests:  
要抓取 AJAX 请求加载的数据，请执行以下操作：

# Find the URL of the AJAX request (using browser's developer tools) and fetch it  
ajax_url = 'https://example.com/ajax_endpoint'  
data = requests.get(ajax_url).json()  # Assuming the response is JSON

# 9. Using Regular Expressions in Web Scraping  
9. 在网页抓取中使用正则表达式

To extract data using regular expressions:  
要使用正则表达式提取数据，请执行以下操作：

import re  
emails = re.findall(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b', html)

# 10. Respecting `robots.txt` 10. 尊重 `robots.txt`

To check `robots.txt` for scraping permissions:  
要检查 `robots.txt` 抓取权限：

from urllib.robotparser import RobotFileParser

rp = RobotFileParser()  
rp.set_url('https://example.com/robots.txt')  
rp.read()  
can_scrape = rp.can_fetch('*', url)

# 11. Using Sessions and Cookies  
11. 使用会话和 Cookie

To maintain sessions and handle cookies:  
要维护会话和处理 Cookie：

session = requests.Session()  
session.get('https://example.com/login')  
session.cookies.set('key', 'value')  # Set cookies, if needed  
response = session.get('https://example.com/protected_page')

# 12. Scraping with Browser Automation (`selenium` Library)  
12. 使用浏览器自动化抓取（ `selenium` 库）

To scrape dynamic content rendered by JavaScript:  
要抓取 JavaScript 呈现的动态内容，请执行以下操作：

from selenium import webdriver  
browser = webdriver.Chrome()  
browser.get('https://example.com')  
content = browser.page_source  
# Parse and extract data using BeautifulSoup, etc.  
browser.quit()

# 13. Error Handling in Web Scraping  
13. 网页抓取中的错误处理

To handle errors and exceptions:  
要处理错误和异常，请执行以下操作：

try:  
    response = requests.get(url, timeout=5)  
    response.raise_for_status()  # Raises an error for bad status codes  
except requests.exceptions.RequestException as e:  
    print(f"Error: {e}")

# 14. Asynchronous Web Scraping  
14. 异步网页抓取

To scrape websites asynchronously for faster data retrieval:  
要异步抓取网站以加快数据检索速度：

import aiohttp  
import asyncio

async def fetch(url):  
    async with aiohttp.ClientSession() as session:  
        async with session.get(url) as response:  
            return await response.text()urls = ['https://example.com/page1', 'https://example.com/page2']  
loop = asyncio.get_event_loop()  
pages = loop.run_until_complete(asyncio.gather(*(fetch(url) for url in urls)))

# 15. Data Storage (CSV, Database)  
15. 数据存储（CSV、数据库）

To store scraped data in a CSV file or a database:  
要将抓取的数据存储在 CSV 文件或数据库中，请执行以下操作：

import csv

with open('output.csv', 'w', newline='') as file:  
    writer = csv.writer(file)  
    writer.writerow(['Title', 'URL'])  
    for article in articles:  
        writer.writerow([article['title'], article['url']])

# Working With `pip` (Package Management)  
使用（ `pip` 包管理）

# 1. Installing a Package 1. 安装软件包

To summon a library from the vast repositories, incorporating its power into your environment:  
要从庞大的存储库中召唤一个库，并将其功能整合到您的环境中：

pip install numpy

# 2. Listing Installed Packages  
2. 列出已安装的软件包

To survey the compendium of libraries that reside within your realm, noting their versions and lineage:  
要调查您领域内的库纲要，并注明其版本和世系：

pip list

# 3. Upgrading a Package 3. 升级软件包

To imbue an installed library with enhanced powers and capabilities, elevating it to its latest form:  
要为已安装的库注入增强的功率和功能，将其提升到最新形式：

pip install --upgrade numpy

# 4. Uninstalling a Package  
4. 卸载软件包

To uninstall a package: 要卸载软件包，请执行以下操作：

pip uninstall numpy

# 5. Searching for Packages  
5. 搜索包裹

Searching packages: 搜索包：

pip search "data visualization"

# 6. Installing Specific Versions of a Package  
6. 安装软件包的特定版本

To install a specific version:  
要安装特定版本，请执行以下操作：

pip install numpy==1.18.5

# 7. Generating a Requirements File  
7. 生成需求文件

Requirements file: 需求文件：

pip freeze > requirements.txt

# 8. Installing Packages from a Requirements File  
8. 从需求文件安装软件包

To conjure a symphony of libraries in unison, each aligned with the notations in your tome of requirements:  
要使图书馆齐声交响乐，每个图书馆都与需求书中的符号保持一致：

pip install -r requirements.txt

# 9. Using Virtual Environments  
9. 使用虚拟环境

Create virtual Environments to manage package conflicts:  
创建虚拟环境以管理包冲突：

# Create a virtual environment named 'venv'  
python -m venv venv

# Activate the virtual environment  
# On Windows  
.\venv\Scripts\activate# On Unix or MacOS  
source venv/bin/activate

# 10. Checking Package Dependencies  
10. 检查包依赖关系

Understanding Dependencies:  
了解依赖关系：

pip show numpy

# Working With Common Built-in Functions and Packages  
使用常见的内置函数和包

# 1. `os` - Operating System Interface  
1. `os` - 操作系统界面

To interact with the operating system:  
要与操作系统交互，请执行以下操作：

import os  
current_directory = os.getcwd()  # Get the current working directory

# 2. `sys` - System-specific Parameters and Functions  
2. `sys` - 系统特定的参数和功能

To access system-specific parameters and functions:  
要访问特定于系统的参数和功能：

import sys  
sys.exit()  # Exit the script

# 3. `datetime` - Basic Date and Time Types  
3. `datetime` - 基本日期和时间类型

To work with dates and times:  
要使用日期和时间：

from datetime import datetime  
now = datetime.now()  # Current date and time

# 4. `math` - Mathematical Functions  
4. `math` - 数学函数

To perform mathematical operations:  
要执行数学运算：

import math  
result = math.sqrt(16)  # Square root

# 5. `random` - Generate Pseudo-random Numbers  
5. `random` - 生成伪随机数

To generate pseudo-random numbers:  
要生成伪随机数：

import random  
number = random.randint(1, 10)  # Random integer between 1 and 10

# 6. `json` - JSON Encoder and Decoder  
6. `json` - JSON编码器和解码器

To parse and generate JSON data:  
要解析和生成 JSON 数据，请执行以下操作：

import json  
json_string = json.dumps({'name': 'Alice', 'age': 30})  # Dictionary to JSON string

# 7. `re` - Regular Expressions  
7. `re` - 正则表达式

To work with regular expressions:  
要使用正则表达式，请执行以下操作：

import re  
match = re.search('Hello', 'Hello, world!')  # Search for 'Hello' in the string

# 8. `urllib` - URL Handling Modules  
8. `urllib` - URL处理模块

To work with URLs: 要使用 URL，请执行以下操作：

from urllib.request import urlopen  
content = urlopen('http://example.com').read()  # Fetch the content of a webpage

# 9. `http` - HTTP Modules  
9. `http` - HTTP 模块

To create HTTP servers and work with HTTP requests:  
要创建 HTTP 服务器并处理 HTTP 请求，请执行以下操作：

from http.server import HTTPServer, BaseHTTPRequestHandler

class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):    def do_GET(self):  
        self.send_response(200)  
        self.send_header('Content-type', 'text/html')  
        self.end_headers()  
        self.wfile.write(b'<html><head><title>Python HTTP Server</title></head>')  
        self.wfile.write(b'<body><h1>Hello from a simple Python HTTP server!</h1></body></html>')def run(server_class=HTTPServer, handler_class=SimpleHTTPRequestHandler):  
    server_address = ('', 8000)  # Serve on all addresses, port 8000  
    httpd = server_class(server_address, handler_class)  
    print("Server starting on port 8000...")  
    httpd.serve_forever()if __name__ == '__main__':  
    run()

# 10. `subprocess` - Subprocess Management  
10. `subprocess` - 子流程管理

To spawn new processes and connect to their input/output/error pipes:  
要生成新进程并连接到其输入/输出/错误管道，请执行以下操作：

import subprocess  
subprocess.run(['ls', '-l'])  # Run the 'ls -l' command

# 11. `socket` - Low-level Networking Interface  
11. `socket` - 低级网络接口

To create network clients and servers:  
要创建网络客户端和服务器，请执行以下操作：

import socket  
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # Create a TCP/IP socket

# 12. `threading` - Thread-based Parallelism  
12. `threading` - 基于线程的并行性

To manage concurrent execution of code:  
要管理代码的并发执行，请执行以下操作：

import threading  
def worker():  
    print("Worker thread executing")  
thread = threading.Thread(target=worker)  
thread.start()

# 13. `multiprocessing` - Process-based Parallelism  
13. `multiprocessing` - 基于进程的并行性

To manage concurrent processes:  
要管理并发进程，请执行以下操作：

from multiprocessing import Process  
def worker():  
    print("Worker process")  
p = Process(target=worker)  
p.start()

# 14. `argparse` - Parser for Command-line Options, Arguments, and Sub-commands  
14. `argparse` - 命令行选项、参数和子命令的解析器

To parse command-line arguments:  
要分析命令行参数，请执行以下操作：

import argparse  
parser = argparse.ArgumentParser(description="Process some integers.")  
args = parser.parse_args()

# 15. `logging` - Logging Facility  
15. `logging` - 伐木设施

To log messages (debug, info, warning, error, and critical):  
要记录消息（调试、信息、警告、错误和严重）：

import logging  
logging.warning('This is a warning message')

# 16. `unittest` - Unit Testing Framework  
16. `unittest` - 单元测试框架

To create and run unit tests:  
若要创建和运行单元测试，请执行以下操作：

import unittest  
class TestStringMethods(unittest.TestCase):  
    def test_upper(self):  
        self.assertEqual('foo'.upper(), 'FOO')

# 17. `pathlib` - Object-oriented Filesystem Paths  
17. `pathlib` - 面向对象的文件系统路径

To work with filesystem paths in an object-oriented way:  
要以面向对象的方式处理文件系统路径，请执行以下操作：

from pathlib import Path  
p = Path('.')

# 18. `functools` - Higher-order Functions and Operations on Callable Objects  
18. `functools` - 可调用对象的高阶函数和操作

To use higher-order functions and operations on callable objects:  
要对可调用对象使用高阶函数和操作，请执行以下操作：

from functools import lru_cache  
@lru_cache(maxsize=None)  
def fib(n):  
    if n < 2:  
        return n  
    return fib(n-1) + fib(n-2)

# 19. `collections` - Container Data Types  
19. `collections` - 容器数据类型

To use specialized container data types (deque, Counter, OrderedDict, etc.):  
要使用专用容器数据类型（deque、Counter、OrderedDict 等）：

from collections import Counter  
c = Counter('hello world')

# 20. `itertools` - Functions Creating Iterators for Efficient Looping  
20. `itertools` - 创建迭代器以实现高效循环的函数

To construct and use iterators for efficient looping:  
要构造和使用迭代器以实现高效循环，请执行以下操作：

import itertools  
for combination in itertools.combinations('ABCD', 2):  
    print(combination)

# 21. `hashlib` - Secure Hash and Message Digest Algorithms  
21. `hashlib` - 安全哈希和消息摘要算法

To hash data: 要对数据进行哈希处理，请执行以下操作：

import hashlib  
hash_object = hashlib.sha256(b'Hello World')  
hex_dig = hash_object.hexdigest()

# 22. `csv` - CSV File Reading and Writing  
22. `csv` - CSV文件读写

To read from and write to CSV files:  
要读取和写入 CSV 文件，请执行以下操作：

import csv  
with open('file.csv', mode='r') as infile:  
    reader = csv.reader(infile)

# 23. `xml.etree.ElementTree` - The ElementTree XML API  
23. `xml.etree.ElementTree` - ElementTree XML API

To parse and create XML data:  
要分析和创建 XML 数据，请执行以下操作：

import xml.etree.ElementTree as ET  
tree = ET.parse('file.xml')  
root = tree.getroot()

# 24. `sqlite3` - DB-API 2.0 Interface for SQLite Databases  
24. `sqlite3` - SQLite 数据库的 DB-API 2.0 接口

To interact with SQLite databases:  
要与 SQLite 数据库交互，请执行以下操作：

import sqlite3  
conn = sqlite3.connect('example.db')

# 25. `tkinter` - GUI Toolkit  
25. `tkinter` - GUI工具包

To create GUI applications:  
要创建 GUI 应用程序，请执行以下操作：

import tkinter as tk  
root = tk.Tk()

# 26. `pickle` - Python Object Serialization  
26. `pickle` - Python 对象序列化

To serialize and deserialize Python object structures:  
要序列化和反序列化 Python 对象结构，请执行以下操作：

import pickle  
serialized_obj = pickle.dumps(obj)

# 27. `io` - Core Tools for Working with Streams  
27. `io` - 用于处理流的核心工具

To handle streams (file-like objects):  
要处理流（类似文件的对象）：

from io import StringIO  
f = StringIO("some initial text data")

# 28. `time` - Time Access and Conversions  
28. `time` - 时间访问和转换

To access time-related functions:  
要访问与时间相关的功能：

import time  
time.sleep(1)  # Sleep for 1 second

# 29. `calendar` - General Calendar-related Functions  
29. `calendar` - 一般日历相关功能

To work with calendars: 要使用日历，请执行以下操作：

import calendar  
print(calendar.month(2023, 1))  # Print the calendar for January 2023

# 30. `queue` - A Synchronized Queue Class  
30. `queue` - 同步队列类

To manage a queue, useful in multithreaded programming:  
要管理队列，在多线程编程中很有用：

from queue import Queue  
q = Queue()

# 31. `shutil` - High-level File Operations  
31. `shutil` - 高级文件操作

To perform high-level file operations, like copying and archiving:  
要执行高级文件操作（如复制和存档），请执行以下操作：

import shutil  
shutil.copyfile('source.txt', 'dest.txt')

# 32. `glob` - Unix Style Pathname Pattern Expansion  
32. `glob` - Unix 风格路径名模式扩展

To find files matching a specified pattern:  
要查找与指定模式匹配的文件，请执行以下操作：

import glob  
for file in glob.glob("*.txt"):  
    print(file)

# 33. `tempfile` - Generate Temporary Files and Directories  
33. `tempfile` - 生成临时文件和目录

To create temporary files and directories:  
要创建临时文件和目录：

import tempfile  
temp = tempfile.TemporaryFile()

# 34. `bz2` - Support for Bzip2 Compression  
34. `bz2` - 支持 Bzip2 压缩

To compress and decompress data using bzip2 compression:  
要使用 bzip2 压缩压缩和解压缩数据：

import bz2  
compressed = bz2.compress(b'your data here')

# 35. `gzip` - Support for Gzip Compression  
35. `gzip` - 支持 Gzip 压缩

To compress and decompress data using gzip compression:  
要使用 gzip 压缩压缩和解压缩数据：

import gzip  
with gzip.open('file.txt.gz', 'wt') as f:  
    f.write('your data here')

# 36. `ssl` - TLS/SSL Wrapper for Socket Objects  
36. `ssl` - 套接字对象的 TLS/SSL 包装器

To handle TLS/SSL encryption and peer authentication for network sockets:  
要处理网络套接字的 TLS/SSL 加密和对等身份验证，请执行以下操作：

import ssl  
ssl.wrap_socket(sock)

# 37. `imaplib` - IMAP4 Protocol Client  
37. `imaplib` - IMAP4 协议客户端

To access and manipulate mail over IMAP4:  
要通过 IMAP4 访问和操作邮件：

import imaplib  
mail = imaplib.IMAP4_SSL('imap.example.com')

# 38. `smtplib` - SMTP Protocol Client  
38. `smtplib` - SMTP客户端协议

To send mail using the Simple Mail Transfer Protocol (SMTP):  
使用简单邮件传输协议 （SMTP） 发送邮件：

import smtplib  
server = smtplib.SMTP('smtp.example.com', 587)

# 39. `email` - Managing Email Messages  
39. `email` - 管理电子邮件

To manage email messages, including MIME and other RFC 2822-based message documents:  
要管理电子邮件，包括 MIME 和其他基于 RFC 2822 的邮件文档，请执行以下操作：

from email.message import EmailMessage  
msg = EmailMessage()

# 40. `base64` - Base16, Base32, Base64, Base85 Data Encodings  
40. `base64` - Base16、Base32、Base64、Base85 数据编码

To encode and decode data using Base64:  
要使用 Base64 对数据进行编码和解码：

import base64  
encoded_data = base64.b64encode(b'data to encode')

# 41. `difflib` - Helpers for Computing Deltas  
41. `difflib` - 计算增量的助手

To compare sequences and produce human-readable diffs:  
要比较序列并生成人类可读的差异：

import difflib  
diff = difflib.ndiff('one\ntwo\nthree\n'.splitlines(keepends=True),  
                     'ore\ntree\nemu\n'.splitlines(keepends=True))  
print(''.join(diff))

# 42. `gettext` - Multilingual Internationalization Services  
42. `gettext` - 多语言国际化服务

To internationalize your Python programs:  
要使 Python 程序国际化，请执行以下操作：

import gettext  
gettext.install('myapp')

# 43. `locale` - Internationalization Services  
43. `locale` - 国际化服务

To access a database of culture-specific data formats:  
要访问特定于区域性的数据格式的数据库，请执行以下操作：

import locale  
locale.setlocale(locale.LC_ALL, '')

# 44. `secrets` - Generate Secure Random Numbers for Managing Secrets  
44. `secrets` - 生成用于管理机密的安全随机数

To generate secure random numbers for managing secrets, such as tokens or passwords:  
要生成用于管理机密（如令牌或密码）的安全随机数，请执行以下操作：

import secrets  
secure_token = secrets.token_hex(16)

# 45. `uuid` - UUID Objects According to RFC 4122  
45. `uuid` - 根据 RFC 4122 的 UUID 对象

To generate universally unique identifiers (UUIDs):  
要生成通用唯一标识符 （UUID）：

import uuid  
unique_id = uuid.uuid4()

# 46. `html` - HyperText Markup Language Support  
46. `html` - 超文本标记语言支持

To handle and manipulate HTML entities:  
要处理和操作 HTML 实体，请执行以下操作：

import html  
escaped = html.escape('<a href="https://example.com">link</a>')

# 47. `ftplib` - FTP Protocol Client  
47. `ftplib` - FTP协议客户端

To interact with and transfer files over the FTP protocol:  
要通过 FTP 协议与文件交互和传输文件：

from ftplib import FTP  
ftp = FTP('ftp.example.com')

# 48. `tarfile` - Read and Write Tar Archive Files  
48. `tarfile` - 读取和写入 Tar 存档文件

To work with tar archive files, allowing you to archive and compress/decompress:  
要处理 tar 存档文件，允许您存档和压缩/解压缩：

import tarfile  
with tarfile.open('sample.tar.gz', 'w:gz') as tar:  
    tar.add('sample.txt')

Well, that’s all I have for now. I hope this list helps you get up to speed fast. If you like it, please share or give it a like (it helps a lot!).  
好吧，这就是我现在所拥有的。我希望这份清单能帮助你快速上手。如果您喜欢它，请分享或点赞（这很有帮助！

Additionally, if you’d like a more in-depth and comprehensive guide to Python Development, there are two books on Amazon that I have found to be the best resources on Python out there for practical python development that I highly recommend. These books are:  
此外，如果您想要更深入、更全面的 Python 开发指南，亚马逊上有两本书，我发现它们是我强烈推荐的 Python 实用开发的最佳资源。这些书是：

1. [Python Crash Course — 3rd Edition  
    Python 速成课程 — 第 3 版](https://www.amazon.com/Python-Crash-Course-Eric-Matthes/dp/1718502702/ref=sr_1_1?crid=2042LZQLOPT7E&amp%3Bkeywords=python+crash+course+3rd+edition&amp%3Bqid=1706557293&amp%3Bsprefix=ps5+controll+d-pad+accessory%252Caps%252C118&amp%3Bsr=8-1&_encoding=UTF8&tag=jasonroell600-20&linkCode=ur2&linkId=d4a7c83a8a3dca8a79c8e6333c47ef76&camp=1789&creative=9325)
2. [Automate the Boring Stuff — 2nd Edition  
    自动化无聊的东西 - 第 2 版](https://www.amazon.com/Automate-Boring-Stuff-Python-2nd-ebook/dp/B07VSXS4NK/ref=sr_1_2_sspa?crid=3GMUETE67088Y&amp%3Bkeywords=automate+the+boring+stuff+with+python+3rd+edition&amp%3Bqid=1706557531&amp%3Bsprefix=automate+the+%252Caps%252C90&amp%3Bsr=8-2-spons&amp%3Bsp_csd=d2lkZ2V0TmFtZT1zcF9hdGY&amp%3Bpsc=1&_encoding=UTF8&tag=jasonroell600-20&linkCode=ur2&linkId=281d357621145f06128d584fe806b644&camp=1789&creative=9325)

Thanks for reading and drop anything I missed in the comments!  
感谢您的阅读，并在评论中留下我错过的任何内容！

[

Python

](https://medium.com/tag/python?source=post_page-----8a33abc0892f---------------python-----------------)

[

Python Programming

](https://medium.com/tag/python-programming?source=post_page-----8a33abc0892f---------------python_programming-----------------)

[

Data Science

](https://medium.com/tag/data-science?source=post_page-----8a33abc0892f---------------data_science-----------------)

[

Data Visualization

](https://medium.com/tag/data-visualization?source=post_page-----8a33abc0892f---------------data_visualization-----------------)

[

Machine Learning

](https://medium.com/tag/machine-learning?source=post_page-----8a33abc0892f---------------machine_learning-----------------)

415

[

![Neelam Yadav](https://miro.medium.com/v2/resize:fill:144:144/1*dP6Rk94ZiKwLz8KynBdReA.png)





](https://medium.com/@yaduvanshineelam09?source=post_page-----8a33abc0892f--------------------------------)

[

## Written by Neelam Yadav 由Neelam Yadav撰写

](https://medium.com/@yaduvanshineelam09?source=post_page-----8a33abc0892f--------------------------------)

[127 Followers](https://medium.com/@yaduvanshineelam09/followers?source=post_page-----8a33abc0892f--------------------------------)

Software engineer, Javascript,Python/Django Data Science , Machine Learning expert, Medium writer. Passionate about sharing knowledge and helping others grow.

Follow

## More from Neelam Yadav 更多Neelam Yadav

![FAST API VS DJANGO :-](https://miro.medium.com/v2/resize:fit:679/0*Hgm5vQDVkAwJNIqg.jpeg)

[

![Neelam Yadav](https://miro.medium.com/v2/resize:fill:20:20/1*dP6Rk94ZiKwLz8KynBdReA.png)



](https://medium.com/@yaduvanshineelam09?source=author_recirc-----8a33abc0892f----0---------------------d0490ca4_e05c_487a_b8bf_42e51da07a50-------)

[

Neelam Yadav 尼拉姆·亚达夫

](https://medium.com/@yaduvanshineelam09?source=author_recirc-----8a33abc0892f----0---------------------d0490ca4_e05c_487a_b8bf_42e51da07a50-------)

[

## FAST API VS DJANGO :- 快速 API 与 DJANGO ：-

### Introduction 介绍



](https://medium.com/@yaduvanshineelam09/fast-api-vs-django-b3633042ca54?source=author_recirc-----8a33abc0892f----0---------------------d0490ca4_e05c_487a_b8bf_42e51da07a50-------)

7 min read·Nov 9, 2023

1K

[

3

](https://medium.com/@yaduvanshineelam09/fast-api-vs-django-b3633042ca54?responsesOpen=true&sortBy=REVERSE_CHRON&source=author_recirc-----8a33abc0892f----0---------------------d0490ca4_e05c_487a_b8bf_42e51da07a50-------)

![Introduction to FastAPI](https://miro.medium.com/v2/resize:fit:679/0*tx-iYU8L50ApJ_EH)

[

![Neelam Yadav](https://miro.medium.com/v2/resize:fill:20:20/1*dP6Rk94ZiKwLz8KynBdReA.png)



](https://medium.com/@yaduvanshineelam09?source=author_recirc-----8a33abc0892f----1---------------------d0490ca4_e05c_487a_b8bf_42e51da07a50-------)

[

Neelam Yadav 尼拉姆·亚达夫

](https://medium.com/@yaduvanshineelam09?source=author_recirc-----8a33abc0892f----1---------------------d0490ca4_e05c_487a_b8bf_42e51da07a50-------)

[

## Introduction to FastAPI FastAPI 简介

### What is an API? 什么是 API？



](https://medium.com/@yaduvanshineelam09/introduction-to-fastapi-123c0b2778a5?source=author_recirc-----8a33abc0892f----1---------------------d0490ca4_e05c_487a_b8bf_42e51da07a50-------)

7 min read·Jan 9, 2024

427

[](https://medium.com/@yaduvanshineelam09/introduction-to-fastapi-123c0b2778a5?responsesOpen=true&sortBy=REVERSE_CHRON&source=author_recirc-----8a33abc0892f----1---------------------d0490ca4_e05c_487a_b8bf_42e51da07a50-------)

![Django React Project Ideas For Beginners In 2024](https://miro.medium.com/v2/resize:fit:679/1*yuVzMhCJyDENbyhwAsrkwA.png)

[

![Neelam Yadav](https://miro.medium.com/v2/resize:fill:20:20/1*dP6Rk94ZiKwLz8KynBdReA.png)



](https://medium.com/@yaduvanshineelam09?source=author_recirc-----8a33abc0892f----2---------------------d0490ca4_e05c_487a_b8bf_42e51da07a50-------)

[

Neelam Yadav 尼拉姆·亚达夫

](https://medium.com/@yaduvanshineelam09?source=author_recirc-----8a33abc0892f----2---------------------d0490ca4_e05c_487a_b8bf_42e51da07a50-------)

[

## Django React Project Ideas For Beginners In 2024  
2024 年面向初学者的 Django React 项目创意

### Welcome to the exciting world of web development! In 2024, diving into the Django React combination for your projects is not just a choice…  
欢迎来到激动人心的 Web 开发世界！在 2024 年，为您的项目深入研究 Django React 组合不仅仅是一种选择......



](https://medium.com/@yaduvanshineelam09/django-react-project-ideas-for-beginners-in-2024-1447f27c0b01?source=author_recirc-----8a33abc0892f----2---------------------d0490ca4_e05c_487a_b8bf_42e51da07a50-------)

6 min read·Jan 2, 2024

669

[

1

](https://medium.com/@yaduvanshineelam09/django-react-project-ideas-for-beginners-in-2024-1447f27c0b01?responsesOpen=true&sortBy=REVERSE_CHRON&source=author_recirc-----8a33abc0892f----2---------------------d0490ca4_e05c_487a_b8bf_42e51da07a50-------)

![Building CRUD API with FastAPI: A Step-by-Step Guide](https://miro.medium.com/v2/resize:fit:679/0*7zqqb_GHavQJevKF.png)

[

![Neelam Yadav](https://miro.medium.com/v2/resize:fill:20:20/1*dP6Rk94ZiKwLz8KynBdReA.png)



](https://medium.com/@yaduvanshineelam09?source=author_recirc-----8a33abc0892f----3---------------------d0490ca4_e05c_487a_b8bf_42e51da07a50-------)

[

Neelam Yadav 尼拉姆·亚达夫

](https://medium.com/@yaduvanshineelam09?source=author_recirc-----8a33abc0892f----3---------------------d0490ca4_e05c_487a_b8bf_42e51da07a50-------)

[

## Building CRUD API with FastAPI: A Step-by-Step Guide  
使用 FastAPI 构建 CRUD API：分步指南

### FastAPI is a modern and high-performance web framework for building APIs with Python. Its ease of use, speed, and support for type hints…  
FastAPI 是一个现代的高性能 Web 框架，用于使用 Python 构建 API。它的易用性、速度和对类型提示的支持......



](https://medium.com/@yaduvanshineelam09/building-crud-api-with-fastapi-a-step-by-step-guide-1e5513546ce5?source=author_recirc-----8a33abc0892f----3---------------------d0490ca4_e05c_487a_b8bf_42e51da07a50-------)

5 min read·Jan 26, 2024

306

[](https://medium.com/@yaduvanshineelam09/building-crud-api-with-fastapi-a-step-by-step-guide-1e5513546ce5?responsesOpen=true&sortBy=REVERSE_CHRON&source=author_recirc-----8a33abc0892f----3---------------------d0490ca4_e05c_487a_b8bf_42e51da07a50-------)

[

See all from Neelam Yadav

](https://medium.com/@yaduvanshineelam09?source=post_page-----8a33abc0892f--------------------------------)

## Recommended from Medium 从中推荐

![The guide to Git I never had.](https://miro.medium.com/v2/resize:fit:679/1*SRMPPL8gPMrJLMqaGo0mCA.png)

[

![Jake Page](https://miro.medium.com/v2/resize:fill:20:20/1*i5p9qg4BGA4i2NXsghlnxQ.png)



](https://medium.com/@jake.page91?source=read_next_recirc-----8a33abc0892f----0---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

[

Jake Page 杰克·佩奇

](https://medium.com/@jake.page91?source=read_next_recirc-----8a33abc0892f----0---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

[

## The guide to Git I never had.  
我从未有过的 Git 指南。

### 🩺 Doctors have stethoscopes.  
🩺 医生有听诊器。



](https://medium.com/@jake.page91/the-guide-to-git-i-never-had-a89048d4703a?source=read_next_recirc-----8a33abc0892f----0---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

13 min read·Apr 11, 2024

1.5K

[

13

](https://medium.com/@jake.page91/the-guide-to-git-i-never-had-a89048d4703a?responsesOpen=true&sortBy=REVERSE_CHRON&source=read_next_recirc-----8a33abc0892f----0---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

![Improve Python Code Quality with Trailing Commas: A Powerful Technique](https://miro.medium.com/v2/resize:fit:679/1*yk-LTQTW8lMJli5EZNz-zw.png)

[

![Kajal Suthar](https://miro.medium.com/v2/resize:fill:20:20/1*KsTfqC0phvC28JcLfEOAyg.jpeg)



](https://medium.com/@kajal.suthar?source=read_next_recirc-----8a33abc0892f----1---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

[

Kajal Suthar 卡贾尔·苏塔尔（Kajal Suthar）

](https://medium.com/@kajal.suthar?source=read_next_recirc-----8a33abc0892f----1---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

in

[

The Pythoneers 蟒蛇

](https://medium.com/pythoneers?source=read_next_recirc-----8a33abc0892f----1---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

[

## Improve Python Code Quality with Trailing Commas: A Powerful Technique  
使用尾随逗号提高 Python 代码质量：一种强大的技术

### Optimizing Python Code Quality Through Trailing Commas For Better Readability  
通过尾随逗号优化 Python 代码质量以提高可读性



](https://medium.com/pythoneers/improve-python-code-quality-with-trailing-commas-a-powerful-technique-757a26d05ca7?source=read_next_recirc-----8a33abc0892f----1---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

4 min read·Apr 8, 2024

406

[

5

](https://medium.com/pythoneers/improve-python-code-quality-with-trailing-commas-a-powerful-technique-757a26d05ca7?responsesOpen=true&sortBy=REVERSE_CHRON&source=read_next_recirc-----8a33abc0892f----1---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

## Lists 列表

[

![](https://miro.medium.com/v2/resize:fill:48:48/0*r4yjMpEmqzHCUvWC.jpg)

![](https://miro.medium.com/v2/resize:fill:48:48/1*bv2KUVNLi2sFNjBTdoBmWw.png)

![](https://miro.medium.com/v2/resize:fill:48:48/0*zsngbTOmFCy6sUCx.jpeg)

## Predictive Modeling w/ Python  
使用 Python 进行预测建模

20 stories·1111 saves



](https://medium.com/@ben.putney/list/predictive-modeling-w-python-e3668ea008e1?source=read_next_recirc-----8a33abc0892f--------------------------------)

[

![Principal Component Analysis for ML](https://miro.medium.com/v2/resize:fill:48:48/1*swd_PY6vTCyPnsgBYoFZfA.png)

![Time Series Analysis](https://miro.medium.com/v2/resize:fill:48:48/1*8sSAHftNwd_RNJ3k4VA0pA.png)

![deep learning cheatsheet for beginner](https://miro.medium.com/v2/resize:fill:48:48/1*uNyD4yNMH-DnOel1wzxOOA.png)

## Practical Guides to Machine Learning  
机器学习实用指南

10 stories·1323 saves



](https://destingong.medium.com/list/practical-guides-to-machine-learning-a877c2a39884?source=read_next_recirc-----8a33abc0892f--------------------------------)

[

![](https://miro.medium.com/v2/da:true/resize:fill:48:48/0*gzCeWxDtGmD23QR5)

![](https://miro.medium.com/v2/resize:fill:48:48/1*di4WDrnS1F6_p9GWnxvPmg.png)

![](https://miro.medium.com/v2/resize:fill:48:48/1*PzJLbFrFtNkqPsxielO8zA.jpeg)

## Coding & Development 编码与开发

11 stories·567 saves



](https://medium.com/@jscribes/list/coding-development-e360d380bb82?source=read_next_recirc-----8a33abc0892f--------------------------------)

[

![](https://miro.medium.com/v2/da:true/resize:fill:48:48/0*7LUbxU6KX9negNKd)

![](https://miro.medium.com/v2/da:true/resize:fill:48:48/1*L7-Vmc55NZrU3WGJfdLeug.gif)

![](https://miro.medium.com/v2/resize:fill:48:48/1*vGQYRtTIDKinw1bQPqf8uQ.png)

## Natural Language Processing  
自然语言处理

1378 stories·872 saves



](https://medium.com/@AMGAS14/list/natural-language-processing-0a856388a93a?source=read_next_recirc-----8a33abc0892f--------------------------------)

![Python MAP/FILTER/REDUCE Explained in 30 Seconds](https://miro.medium.com/v2/resize:fit:679/1*nAI4c2xCJB-GsoBO37HLuA.png)

[

![Liu Zuo Lin](https://miro.medium.com/v2/resize:fill:20:20/1*Z5dMY4-vS6G69lMMdn3xIQ.jpeg)



](https://medium.com/@zlliu?source=read_next_recirc-----8a33abc0892f----0---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

[

Liu Zuo Lin 刘作林

](https://medium.com/@zlliu?source=read_next_recirc-----8a33abc0892f----0---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

in

[

Level Up Coding 升级编码

](https://medium.com/gitconnected?source=read_next_recirc-----8a33abc0892f----0---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

[

## Python MAP/FILTER/REDUCE Explained in 30 Seconds  
Python MAP/FILTER/REDUCE 在 30 秒内解释

### # If you read really fast  
# 如果你读得很快



](https://medium.com/gitconnected/python-map-filter-reduce-explained-in-30-seconds-c64633ca305c?source=read_next_recirc-----8a33abc0892f----0---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

·3 min read·Apr 11, 2024

823

[

3

](https://medium.com/gitconnected/python-map-filter-reduce-explained-in-30-seconds-c64633ca305c?responsesOpen=true&sortBy=REVERSE_CHRON&source=read_next_recirc-----8a33abc0892f----0---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

![Mojo, 90,000 Times Faster Than Python, Finally Open Sourced!](https://miro.medium.com/v2/resize:fit:679/0*0VcMppg3rDTqfsMY)

[

![Dylan Cooper](https://miro.medium.com/v2/resize:fill:20:20/1*RRrzcpyclrRriAy6HIA-1g@2x.png)



](https://medium.com/@dylan_cooper?source=read_next_recirc-----8a33abc0892f----1---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

[

Dylan Cooper 迪伦·库珀

](https://medium.com/@dylan_cooper?source=read_next_recirc-----8a33abc0892f----1---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

in

[

Stackademic 堆栈

](https://medium.com/stackademic?source=read_next_recirc-----8a33abc0892f----1---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

[

## Mojo, 90,000 Times Faster Than Python, Finally Open Sourced!  
Mojo，比 Python 快 90,000 倍，终于开源了！

### On March 29, 2024, Modular Inc. announced the open sourcing of the core components of Mojo.  
2024 年 3 月 29 日，Modular Inc. 宣布开源 Mojo 的核心组件。



](https://medium.com/stackademic/mojo-90-000-times-faster-than-python-finally-open-sourced-777bdd9a1896?source=read_next_recirc-----8a33abc0892f----1---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

·10 min read·Apr 9, 2024

2.9K

[

20

](https://medium.com/stackademic/mojo-90-000-times-faster-than-python-finally-open-sourced-777bdd9a1896?responsesOpen=true&sortBy=REVERSE_CHRON&source=read_next_recirc-----8a33abc0892f----1---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

![Don’t Repeat My Mistakes: Advanced Python Pitfalls to Avoid](https://miro.medium.com/v2/resize:fit:679/0*mE0ajhsih9mJjnWT)

[

![Builescu Daniel](https://miro.medium.com/v2/resize:fill:20:20/1*Po-3MI77TLoC48J313Ct-Q.gif)



](https://medium.com/@danielbuilescu?source=read_next_recirc-----8a33abc0892f----2---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

[

Builescu Daniel 布莱斯库·丹尼尔

](https://medium.com/@danielbuilescu?source=read_next_recirc-----8a33abc0892f----2---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

in

[

Python in Plain English Python 简明英语

](https://medium.com/python-in-plain-english?source=read_next_recirc-----8a33abc0892f----2---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

[

## Don’t Repeat My Mistakes: Advanced Python Pitfalls to Avoid  
不要重蹈覆辙：要避免的高级 Python 陷阱

### Level up your Python: Lessons from an ex-Googler  
升级你的 Python：来自前 Google 员工的教训



](https://medium.com/python-in-plain-english/dont-repeat-my-mistakes-advanced-python-pitfalls-to-avoid-6b5bec6e2cc0?source=read_next_recirc-----8a33abc0892f----2---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

·8 min read·6 days ago

556

[

3

](https://medium.com/python-in-plain-english/dont-repeat-my-mistakes-advanced-python-pitfalls-to-avoid-6b5bec6e2cc0?responsesOpen=true&sortBy=REVERSE_CHRON&source=read_next_recirc-----8a33abc0892f----2---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

![Mastering Exploratory Data Analysis (EDA): Everything You Need To Know](https://miro.medium.com/v2/resize:fit:679/0*N0tNReSd5NhYEyE2)

[

![Sze Zhong LIM](https://miro.medium.com/v2/resize:fill:20:20/1*Xhvo4lW6IEWIL4oe-kB5SA.jpeg)



](https://medium.com/@limszezhong?source=read_next_recirc-----8a33abc0892f----3---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

[

Sze Zhong LIM 林中华

](https://medium.com/@limszezhong?source=read_next_recirc-----8a33abc0892f----3---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

in

[

Data And Beyond 数据及其他

](https://medium.com/data-and-beyond?source=read_next_recirc-----8a33abc0892f----3---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

[

## Mastering Exploratory Data Analysis (EDA): Everything You Need To Know  
掌握探索性数据分析 （EDA）：您需要知道的一切

### A systematic approach to EDA your data and prep it for machine learning.  
一种系统化的方法，对数据进行 EDA 并为机器学习做好准备。



](https://medium.com/data-and-beyond/mastering-exploratory-data-analysis-eda-everything-you-need-to-know-7e3b48d63a95?source=read_next_recirc-----8a33abc0892f----3---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

18 min read·Apr 6, 2024

341

[

3

](https://medium.com/data-and-beyond/mastering-exploratory-data-analysis-eda-everything-you-need-to-know-7e3b48d63a95?responsesOpen=true&sortBy=REVERSE_CHRON&source=read_next_recirc-----8a33abc0892f----3---------------------8d477aff_bb8a_4791_9b18_6853fdf4988d-------)

[

See more recommendations

](https://medium.com/?source=post_page-----8a33abc0892f--------------------------------)

[

Help

](https://help.medium.com/hc/en-us?source=post_page-----8a33abc0892f--------------------------------)

[

Status

](https://medium.statuspage.io/?source=post_page-----8a33abc0892f--------------------------------)

[

About

](https://medium.com/about?autoplay=1&source=post_page-----8a33abc0892f--------------------------------)

[

Careers

](https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=post_page-----8a33abc0892f--------------------------------)

[

Blog

](https://blog.medium.com/?source=post_page-----8a33abc0892f--------------------------------)

[

Privacy

](https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----8a33abc0892f--------------------------------)

[

Terms

](https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----8a33abc0892f--------------------------------)

[

Text to speech

](https://speechify.com/medium?source=post_page-----8a33abc0892f--------------------------------)

[

Teams

](https://medium.com/business?source=post_page-----8a33abc0892f--------------------------------)